#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{prettyref}
\newrefformat{}{section~\ref{#1}}
\sloppy
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman newcent
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 0
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Diligence
\end_layout

\begin_layout Author
Version @VERSION@
\begin_inset Newline newline
\end_inset

Main text written by Tal Liron
\end_layout

\begin_layout Standard
\noindent
\align center
Copyright 2011-2012 by Three Crickets LLC.
\begin_inset Newline newline
\end_inset

This work is licensed under a
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License"
target "http://creativecommons.org/licenses/by-nc-sa/3.0/"

\end_inset

.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Authentication Service
\end_layout

\begin_layout Standard
This all-important service manages a few systems, which together allow your
 site to be 
\begin_inset Quotes eld
\end_inset

logged into
\begin_inset Quotes erd
\end_inset

 by individual users.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Authentication"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Authentication"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Users
\end_layout

\begin_layout Standard
Users are maintained in a simple MongoDB collection.
 You can easily attach settings to any user document, which can have any
 structure and depth you need.
\end_layout

\begin_layout Standard
Passwords are hashed many times and stored with a random salt.
 This good practice makes sure that even if a hacker were to steal your
 database and hack into a few accounts, they would not be able to use the
 results of their work to crack the other passwords.
\end_layout

\begin_layout Standard
Users are considered 
\begin_inset Quotes eld
\end_inset

entities
\begin_inset Quotes erd
\end_inset

 by the <a href="../authorization/">authorization service</a>, such that you
 can attach permissions to user documents.
 Users can inherit permissions from groups and from other users.
\end_layout

\begin_layout Standard
Though you can maintain the user documents yourself, you can add the <a
 href="../../feature/registration/">registration feature</a> to allow individuals
 to create their own users.
\end_layout

\begin_layout Subsubsection
Sessions
\end_layout

\begin_layout Standard
When users do log in, they get a cookie with a session ID, which matches
 a document in the sessions collection.
 Thus, every conversation is associated with a session.
 You can store anything you want in the session document.
\end_layout

\begin_layout Standard
The <a href="../authorization/">authorization service</a> can check any operation
 against the conversation's session to make sure it's permitted.
\end_layout

\begin_layout Standard
The service comes with a task to make sure to remove sessions that have
 not been used for a while.
 It's a good security feature! (People tend to forget to log out, which
 can be especially dangerous in public places.)
\end_layout

\begin_layout Subsubsection
Caching Per User
\end_layout

\begin_layout Standard
This very powerful feature uses a cache key patten handler to inject the
 currently logged in user ID into the cache key.
 This lets you cache any /web/dynamic/ or /web/fragment/ resource <i>per
 user</i>, which can do wonders towards helping your site scale.
 Of course, it does not make sense to cache every dynamic part of a page,
 but if you can indetify those fragments that look different only for different
 users then you've achieved a lot.
\end_layout

\begin_layout Subsubsection
Authentication Forms
\end_layout

\begin_layout Standard
The authentication service comes with a bunch of /web/fragments/ that you
 can easily drop in to any page.
 They handle things like logging in, logging out, and showing the currently
 logged-in user.
\end_layout

\begin_layout Subsubsection
Providers
\end_layout

\begin_layout Standard
Using Diligence's plug-ins library, the authentication service adds transparent
 support for 3rd-party authentication providers.
 Currently supported providers are Facebook, Windows Live, Twitter and OpenID
 (tested with Google, Yahoo, Myspace, LiveJournal).
\end_layout

\begin_layout Standard
Users coming from outside are real users: the first time they log in, a
 user document is created for them in the collection, and it can join in
 with settings, permissions, etc.
 Depending on how your application works, you can treat these users as any
 other user, or use the authorization service to treat them as 
\begin_inset Quotes eld
\end_inset

guests
\begin_inset Quotes erd
\end_inset

 with the ability to do only certain tasks.
 All 3rd-party users are automatically associated with an authorization
 group named after their provider.
 So, you can grant special permissions (or deny permissions) to 
\begin_inset Quotes eld
\end_inset

facebook.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This useful feature allows your application to be especially welcoming.
 Studies have shown that typical users think twice when a site requires
 <a href="../../feature/registration/">registration</a>.
 People either don't want to invest the effort in registering, or are anxious
 about yet another copy of their personal data being stored in somebody's
 database.
\end_layout

\begin_layout Section
Authorization Service
\end_layout

\begin_layout Standard
When used with the <a href="../authentication/">authentication service</a>,
 this service lets you secure your site by allowing only authorized users
 to access certain resources or perform certain operations.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Authorization"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Authorizaion"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Entities and Inheritance
\end_layout

\begin_layout Standard
Permissions are associated with 
\begin_inset Quotes eld
\end_inset

entities,
\begin_inset Quotes erd
\end_inset

 which could be either individual users (from the <a href="../authentication/">aut
hentication service</a>), or groups, which are here stores in a simple MongoDB
 collection.
\end_layout

\begin_layout Standard
Each entity can inherit permissions from any number of other entities, in
 order.
 The common use case is for a user to 
\begin_inset Quotes eld
\end_inset

belong
\begin_inset Quotes erd
\end_inset

 to a few groups, and inherit their permissions.
 This lets you centrally manage permissions for large groups of users, and
 easily change a user's permission profile by changing their groups.
 Entities can inherit from other entities, and so on.
\end_layout

\begin_layout Standard
Permissions will be overriden by the inheritor: for example, if you specifically
 grant a user permission to edit a certain page, they will have this permission
 even if the group they inherit from specifically forbids it.
 The order of inheritance also allows for overriding.
\end_layout

\begin_layout Subsubsection
Cascading Permissions
\end_layout

\begin_layout Standard
The common practice is to name permissions using a hierarchical dot notation,
 with each level of depth corresponding to moving into a specific section,
 resource or operation in your application.
 In some cases, it may make sense to treat a permission as if it covers
 all sub-permissions in a hierarchy.
 Here we call this 
\begin_inset Quotes eld
\end_inset

cascading permissions.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Backup Service
\end_layout

\begin_layout Standard
This service lets you do a live export of your MongoDB databases and collections
 to JSON, optionally gzipping the output to save space.
 You can set up your application's 
\begin_inset Quotes eld
\end_inset

crontab
\begin_inset Quotes erd
\end_inset

 to have the backup run regularly.
\end_layout

\begin_layout Standard
Backups are very fast: large databases can be fully exported in durations
 measured in seconds or minutes.
\end_layout

\begin_layout Standard
You might wonder what advantages this service has over MongoDB's 
\begin_inset CommandInset href
LatexCommand href
name "mongodump or mongoexport tools"
target "http://www.mongodb.org/display/DOCS/Import+Export+Tools"

\end_inset

.
 First, from our experience, the admin tools that come with MongoDB are
 overly simplistic and unreliable.
 Otherwise, Diligence's backup service offers the following advantages:
\end_layout

\begin_layout Itemize

\series bold
Thoughput:
\series default
 Because we're using the Java MongoDB driver underneath, with its support
 for connection pooling, we can achieve much higher throughput than the
 command line tools, which use a single connection and no concurrency.
 The default is to use 5 threads (and thus 5 connections at most) at once.
\end_layout

\begin_layout Itemize

\series bold
True JSON:
\series default
 The mongoexport tool does not export a real JSON array, instead it exports
 each document as a JSON dict, separating each document with a newline.
 Diligence exports a standard JSON array, readable from any standard JSON
 parser.
\end_layout

\begin_layout Itemize

\series bold
Consistency:
\series default
 Works with the same MongoDB connection as your application, guaranteeing
 that you're backing up 
\emph on
exactly
\emph default
 the same data your application sees.
 This is especially important in a sharded or replica set deployment.
\end_layout

\begin_layout Itemize

\series bold
Operations:
\series default
 You don't have to create system scripts to backup your DB.
 Instead, you can stay in JavaScript and Diligence.
 You do not even need MongoDB or its command line tools installed.
\end_layout

\begin_layout Itemize

\series bold
Iterators:
\series default
 The backup service uses Diligence <a href="../../foundation/iterators/">iterators</
a>, so you can transform your data in various ways while backing up, or
 even include non-MongoDB data.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Backup"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Backup"

\end_inset

.
\end_layout

\begin_layout Standard
To export the whole database:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/backup/')
\end_layout

\begin_layout Plain Layout

Diligence.Backup.exportMongoDb({directory: '/tmp/savory-backup/'})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The API further lets you select the MongoDB database and collections you
 wish to export, otherwise by default it uses the current default database
 and goes through all collections.
 You can also set 
\begin_inset Quotes eld
\end_inset

gzip
\begin_inset Quotes erd
\end_inset

 to true in order to gzip the resulting files.
\end_layout

\begin_layout Standard
To schedule the backup to run every day at 6am, add this to your 
\begin_inset Quotes eld
\end_inset

crontab
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

* 6 * * * <% document.executeOnce('/savory/service/backup/'); Diligence.Backup.expo
rtMongoDb({directory: '/tmp/savory-backup/', gzip: true}); %>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To import a collection:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Diligence.Backup.importMongoDbCollection({file: '/tmp/savory-backup/users.json'})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The collection name will be parsed from the filename.
 If the filename ends with 
\begin_inset Quotes eld
\end_inset

.gz
\begin_inset Quotes erd
\end_inset

, it will be assumed to be gzipped and unzipped accordingly.
 (For example 
\begin_inset Quotes eld
\end_inset

/tmp/savory-backup/users.json.gz
\begin_inset Quotes erd
\end_inset

.) By default the imported documents will be merged into the collection:
 set the 
\begin_inset Quotes eld
\end_inset

drop
\begin_inset Quotes erd
\end_inset

 key true if you want the collection to be dropped before importing.
\end_layout

\begin_layout Section
Documents Service
\end_layout

\begin_layout Standard
This service lets you store versioned HTML documents in MongoDB using your
 choice among several markup languages: 
\begin_inset CommandInset href
LatexCommand href
name "Markdown"
target "http://daringfireball.net/projects/markdown/"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Textile"
target "http://redcloth.org/textile"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Confluence"
target "http://confluence.atlassian.com/display/DOC/Confluence+Wiki+Markup"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "MediaWiki"
target "http://www.mediawiki.org/wiki/Help:Formatting"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "TWiki"
target "http://twiki.org/cgi-bin/view/TWiki/TextFormattingRules"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "Trac"
target "http://trac.edgewall.org/wiki/WikiFormatting"

\end_inset

.
 It's thus an essential building block for CMS features, such as wikis and
 blogs.
\end_layout

\begin_layout Standard
Every 
\begin_inset Quotes eld
\end_inset

document
\begin_inset Quotes erd
\end_inset

 in this service is indeed a single MongoDB document, but internally it
 composed of versioned 
\begin_inset Quotes eld
\end_inset

drafts
\begin_inset Quotes erd
\end_inset

.
 The last draft (of the highest revision number) represents the current
 state of the document.
 For efficiency, the last draft in its own key (
\begin_inset Quotes eld
\end_inset

activeDraft
\begin_inset Quotes erd
\end_inset

), allowing you to retrieve it from MongoDB without retrieving the whole
 history of drafts, which is an array.
 Additionally, each draft is stored both as markup source code and as rendered
 result, so that rendering only happens once.
\end_layout

\begin_layout Standard
MongoDB atomic operations guarantee that even if more than one person is
 revising a document at the same, no draft will be lost.
 Only last update to come in, though, will get to set the 
\begin_inset Quotes eld
\end_inset

activeDraft
\begin_inset Quotes erd
\end_inset

 key.
\end_layout

\begin_layout Standard
Documents are associated with a 
\begin_inset Quotes eld
\end_inset

site
\begin_inset Quotes erd
\end_inset

, of which there must be at least one.
 The Document Service can handle many 
\begin_inset Quotes eld
\end_inset

sites
\begin_inset Quotes erd
\end_inset

 at once, each with its own set of documents.
 The versioning system is designed to be global per each site, meaning that
 all drafts associated with a site will have 
\emph on
serial 
\emph default
and 
\emph on
unique 
\emph default
revision numbers per that site.
 This allows time travel: you that you can view the entire state of a site
 at a given time by fetching only drafts smaller than a certain revision.
 (This also implies that every draft as its own unique revision number,
 but there's no easy way in MongoDB to traverse drafts in this order.)
\end_layout

\begin_layout Standard
Note the markup rendering is handled by a lower-level library, 
\begin_inset CommandInset href
LatexCommand href
name "Savory.HTML"
target "http://threecrickets.com/javascript-api/?namespace=Savory.HTML"

\end_inset

, which you can choose to use directly if you do not need the versioning
 system.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Documents"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Documents"

\end_inset

.
\end_layout

\begin_layout Standard
The API doesn't actually encourage you to access 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 directly.
 Instead, you access 
\begin_inset Quotes eld
\end_inset

drafts
\begin_inset Quotes erd
\end_inset

 via the document ID and its revision, or simply request the latest draft.
 As stated above, the API is designed to be very efficient in doing this:
 whether it's the latest draft you need or a specific older revision, it's
 a very direct MongoDB fetch.
\end_layout

\begin_layout Standard
To fetch the latest draft by the document ID and print out its rendered
 HTML:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/documents/')
\end_layout

\begin_layout Plain Layout

var draft = Diligence.Documents.getDraft('4fc4457ae4b030c6611c072f')
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

<%= draft.render() %>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Efficiency note: if that particular draft has already been rendered once,
 the render() call won't do anything at all, the rendered version having
 already been fetched.
 Other options for fetching drafts: you can also call 
\begin_inset Quotes eld
\end_inset

getLatestDraft
\begin_inset Quotes erd
\end_inset

 with a maximum revision number, or just call 
\begin_inset Quotes eld
\end_inset

getDraft
\begin_inset Quotes erd
\end_inset

 with a specific revision number you want.
\end_layout

\begin_layout Standard
To revise a draft, meaning that you will add a new revision to the document:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

draft.revise('this is the markup source', 'textile')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after revision, the draft object is updated with the new information.
 So you can call 
\begin_inset Quotes eld
\end_inset

draft.getRevision()
\begin_inset Quotes erd
\end_inset

 to see the new revision number if you need it.
 Again, remember that this particular revision number will be unique for
 the entire 
\begin_inset Quotes eld
\end_inset

site
\begin_inset Quotes erd
\end_inset

: no other document or draft will have it.
\end_layout

\begin_layout Standard
To create a new document:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var site = Diligence.Documents.getSite('4d5595e3f7f2d14d2ab9630f')
\end_layout

\begin_layout Plain Layout

var draft = site.createDocument('a new document!', 'textile')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Quotes eld
\end_inset

createDocument
\begin_inset Quotes erd
\end_inset

 returns a draft object, which will be the first and only draft of the document.
\end_layout

\begin_layout Standard
As you you can see, the usage is simple and efficient, but the implementation
 does have some sophistication.
 It's recommended that you look at the MongoDB collections for 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

sites
\begin_inset Quotes erd
\end_inset

 to get a sense of how they work together.
\end_layout

\begin_layout Subsubsection
Integration
\end_layout

\begin_layout Standard
To integrate the Documents Service into your application, use the document
 ID by called 
\begin_inset Quotes eld
\end_inset

getDocumentId()
\begin_inset Quotes erd
\end_inset

 on a draft object, and then store that ID in your own structure.
 For example, if you're writing a wiki, you might want to associate a wiki
 page with that document ID.
 Similarly for a blog entry.
 And, of course, this is schema-free MongoDB: feel free to add whatever
 data you need to your 
\begin_inset Quotes eld
\end_inset

document
\begin_inset Quotes erd
\end_inset

 documents.
 You can also inherit the Document Service classes and add the necessary
 functionality.
\end_layout

\begin_layout Standard
An important feature of wiki markup languages is support for special processing
 of wiki page references, turning them into HTML hyperlinks and possibly
 creating the page in the wiki.
 The Documents Service lets you hook in your code to support custom delimiters,
 so it can output proper links.
 Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var rendered = draft.render({
\end_layout

\begin_layout Plain Layout

	codes: {
\end_layout

\begin_layout Plain Layout

		start: '{{',
\end_layout

\begin_layout Plain Layout

		end: '}}',
\end_layout

\begin_layout Plain Layout

		fn: function(text) {
\end_layout

\begin_layout Plain Layout

			return '<a href="/link/{0}">{0}</a>'.cast(text)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You could then insert these custom codes in your markup:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

This is a link to {{mywikitopic}}.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

codes
\begin_inset Quotes erd
\end_inset

 key can be an array of several such code processors, and the function can
 output anything at all, not just links, so you can use it to extend the
 markup language.
 In fact, the function can actually do something more substantial than output:
 you could, for example, save a cross reference to the remote wiki page,
 or create an empty template for a non-existing page.
\end_layout

\begin_layout Standard
Note that custom code processing happens only during the first render: in
 subsequent calls to 
\begin_inset Quotes eld
\end_inset

render()
\begin_inset Quotes erd
\end_inset

 on this draft the 
\begin_inset Quotes eld
\end_inset

codes
\begin_inset Quotes erd
\end_inset

 argument will be ignored.
\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
If you like, you can avoid specifying the markup language in all the API
 calls.
 The default language would then be 
\begin_inset Quotes eld
\end_inset

textile
\begin_inset Quotes erd
\end_inset

, but you can change it in your application's 
\begin_inset Quotes eld
\end_inset

settings.js
\begin_inset Quotes erd
\end_inset

 by adding something like this to your app.globals:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.globals = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	savory: {
\end_layout

\begin_layout Plain Layout

		service: {
\end_layout

\begin_layout Plain Layout

			documents: {
\end_layout

\begin_layout Plain Layout

				defaultLanguage: 'markdown'
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Events Service
\end_layout

\begin_layout Standard
Almost every application framework provides some generic way to listen to
 and fire one-way messages called 
\begin_inset Quotes eld
\end_inset

events.
\begin_inset Quotes erd
\end_inset

 By decoupling event producer code from event consumer code, you can allow
 for a looser, more dynamic code architecture.
\end_layout

\begin_layout Standard
Some frameworks go a step beyond simple code decoupling, and treat producers
 and consumers as separate 
\emph on
components
\emph default
, in which the producer cannot make any assumptions on the consumer's thread
 behavior.
 Consider two extremes: a consumer might respond to events immediately,
 in thread, possibly tying up the producer's thread in the process.
 Or, it might allow for events to be queued up, and poll occasionally to
 handle them.
 In the latter highly abstracted situations, events are called 
\begin_inset Quotes eld
\end_inset

messages,
\begin_inset Quotes erd
\end_inset

 and implementations often involve sophisticated middleware to queue messages,
 persist them, create interdependencies, and make sure they travel from
 source to destination via repeated attempts, back-off algorithms, notifications
 to system administrators in case of failure, etc.
\end_layout

\begin_layout Standard
One size does not fit all.
 With Diligence, we wanted to keep events lightweight: we assume that your
 consumer and producer components are all running inside a Prudence container:
 either they are explicit or implicit resources running in web request threads,
 or they are asynchronous tasks.
 This allows us to optimize for this situation without having to rely on
 abstracting middleware.
 Still, more sophisticated, dedicated messaging middleware is out there
 and available if you need it.
 We suggest you try 
\begin_inset CommandInset href
LatexCommand href
name "RabbitMQ"
target "http://www.rabbitmq.com/"

\end_inset

.
\end_layout

\begin_layout Standard
That said, the combination of Prudence Hazelcast clusters, MongoDB, and
 JavaScript's inherent dynamism within the Prudence container allows for
 a truly scalable event framework.
 If what you need is asynchrony and scalable distribution, rather than generic
 decoupling, then Diligence events might be far more useful and simpler
 than deploying complex middleware.
\end_layout

\begin_layout Quote
The point of an event-driven architecture is that you're relinquishing some
 control of your code-flow.
 It's thus hard to know, simply by looking at the code, which parts of it
 will be triggered when an event is fired.
 You also need to know what exactly is subscribing and where that listener
 code is.
 Decoupling code is a great way to introduce some really difficult bugs
 into your codebase, and vastly reduce its debuggability.
 We present this service for your use, but encourage you to think of the
 costs vs.
 the benefits in terms of code clarity.
 Perhaps there is a more straightforward way to solve your problem? If all
 you need as asynchronicity, then you can also use the 
\begin_inset CommandInset href
LatexCommand href
name "Prudence.Task API"
target "http://threecrickets.com/javascript-api/?namespace=Prudence.Task"

\end_inset

 more directly, allowing you to call 
\emph on
specific
\emph default
 listening code, rather than any generic subscriber.
 The bottom line is that as great as this service is, we recommend using
 it with discrimination.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Events"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Events"

\end_inset

.
\end_layout

\begin_layout Subsubsection
In-Thread Events
\end_layout

\begin_layout Standard
First, the basics.
 Here's our 
\begin_inset Quotes eld
\end_inset

/libraries/politeness/acknowledgements.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Diligence.Events.subscribe({
\end_layout

\begin_layout Plain Layout

	name: 'payments.successful',
\end_layout

\begin_layout Plain Layout

	fn: function(name, context) {
\end_layout

\begin_layout Plain Layout

		logger.info('User {0} has paid us {1}!', context.username, context.amount)
\end_layout

\begin_layout Plain Layout

		Acknowledgements.sendThankYou(context.username)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, to fire the event, somewhere in our payments workflow:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/politeness/acknowledgements/')
\end_layout

\begin_layout Plain Layout

Diligence.Events.fire({
\end_layout

\begin_layout Plain Layout

	name: 'payments.successful',
\end_layout

\begin_layout Plain Layout

	context: {
\end_layout

\begin_layout Plain Layout

		username: user.name,
\end_layout

\begin_layout Plain Layout

		id: user.id,
\end_layout

\begin_layout Plain Layout

		amount: payment.amount
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For this to work, you have to make sure the firing code has already run
 the code that hooks up the listeners.
 Often, a simple document.execute will do the trick, as in this example.
\end_layout

\begin_layout Subsubsection
Asynchronous Events
\end_layout

\begin_layout Standard
You can easily make the listeners run outside your thread, in fact anywhere
 in your Prudence cluster.
 This, of course, is crucial for scalability, because you don't want the
 listeners holding your web request thread.
\end_layout

\begin_layout Standard
For this to work, we need to add something small to our subscription:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Diligence.Events.subscribe({
\end_layout

\begin_layout Plain Layout

	name: 'payments.successful',
\end_layout

\begin_layout Plain Layout

	dependencies: '/politeness/acknowledgements/',
\end_layout

\begin_layout Plain Layout

	fn: function(name, context) {
\end_layout

\begin_layout Plain Layout

		logger.info('User {0} has paid us {1}!', context.username, context.amount)
\end_layout

\begin_layout Plain Layout

		Acknowledgements.sendThankYou(context.username)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that we had to add a 
\begin_inset Quotes eld
\end_inset

dependencies
\begin_inset Quotes erd
\end_inset

 key to the listener, to allow it to be called in different contexts.
 These dependencies are document.executeOnce'd to make sure the calling thread
 has access to all the code it needs.
\end_layout

\begin_layout Standard
Firing it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/politeness/acknowledgements/')
\end_layout

\begin_layout Plain Layout

Diligence.Events.fire({
\end_layout

\begin_layout Plain Layout

	name: 'payments.successful',
\end_layout

\begin_layout Plain Layout

	async: true,
\end_layout

\begin_layout Plain Layout

	context: {
\end_layout

\begin_layout Plain Layout

		username: user.name,
\end_layout

\begin_layout Plain Layout

		id: user.id,
\end_layout

\begin_layout Plain Layout

		amount: payment.amount
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All we did was add 
\begin_inset Quotes eld
\end_inset

async: true
\begin_inset Quotes erd
\end_inset

, and\SpecialChar \ldots{}
 that's pretty much it.
 Every listener will run in its own thread within the global pool.
 You can add a 
\begin_inset Quotes eld
\end_inset

distributed: true
\begin_inset Quotes erd
\end_inset

 flag to cause listeners to be executed anywhere in the cluster, and there's
 where things get really powerful: you can properly scale out your event
 handling in the cluster, with nothing more than a simple flag.
\end_layout

\begin_layout Standard
How does this magic work? It's JavaScript magic: 
\emph on
we're evaluating the serialized listener source code
\emph default
.
 The code that fires the event is called via <a href="../tasks/">Prudence's
 tasks library</a>.
 The task makes sure to run the dependencies and evaluate the JavaScript
 you stored.
 Voila.
 (Serialization and eval will only occur on async events: otherwise, it's
 a regular function call.)
\end_layout

\begin_layout Standard
Concerned about JavaScript eval performance? Generally, it's very fast,
 and surely whatever overhead is required to parse the JavaScript grammar
 would be less than any network I/O that a distributed event would involve.
 If you're really worried about performance, make sure to store as little
 code as possible in the listener function and quickly delegate to compiled
 code.
 For example, your listener can simply call a function from one of the dependenc
y libraries, which are already compiled and at their most efficient.
\end_layout

\begin_layout Subsubsection
Stored Listeners
\end_layout

\begin_layout Standard
So far so good, but both examples above require you to execute the code
 that subscribes the listeners before firing the event.
 Stored listeners remove this requirement by saving the event and its listeners
 in one of several storage implementations.
\end_layout

\begin_layout Standard
For example, let's store our listeners in application.distributedGlobals,
 so that we can fire the event anywhere in the Prudence cluster:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var globalEvents = new Diligence.Events.GlobalsStore(application.distributedGlobals
, 'myevents.')
\end_layout

\begin_layout Plain Layout

Diligence.Events.subscribe({
\end_layout

\begin_layout Plain Layout

	name: 'payments.successful',
\end_layout

\begin_layout Plain Layout

	stores: globalEvents,
\end_layout

\begin_layout Plain Layout

	id: 'sendThankYou',
\end_layout

\begin_layout Plain Layout

	dependencies: '/politeness/acknowledgements/',
\end_layout

\begin_layout Plain Layout

	fn: function(name, context) {
\end_layout

\begin_layout Plain Layout

		logger.info('User {0} has paid us {1}!', context.username, context.amount)
\end_layout

\begin_layout Plain Layout

		Acknowledgements.sendThankYou(context.username)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also use application.globals or application.sharedGlobals.
\end_layout

\begin_layout Standard
One small issue to note when using stored listeners is that storage must
 support concurrency.
 One implication of this is that you need to make sure that they are not
 registered more than once, say by multiple nodes in the cluster, otherwise
 your listener code would be called multiple times.
 And that's what the listener 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 field is for.
 (In fact, the 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 field can also be used for in-thread listeners.) It also might make sense
 to set up all your stored listeners in your 
\begin_inset Quotes eld
\end_inset

/startup/
\begin_inset Quotes erd
\end_inset

 task, but it's not a requirement: you can install listeners whenever necessary
 and relevant.
\end_layout

\begin_layout Standard
Because it's stored, firing the event does not require us to execute the
 listener code first in our thread.
 We can remain blissfully unaware of who or what is subscribed to our event:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Diligence.Events.fire({
\end_layout

\begin_layout Plain Layout

	name: 'payments.successful',
\end_layout

\begin_layout Plain Layout

	stores: globalEvents,
\end_layout

\begin_layout Plain Layout

	async: true,
\end_layout

\begin_layout Plain Layout

	distributed: true,
\end_layout

\begin_layout Plain Layout

	context: {
\end_layout

\begin_layout Plain Layout

		username: user.name,
\end_layout

\begin_layout Plain Layout

		id: user.id,
\end_layout

\begin_layout Plain Layout

		amount: payment.amount
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

stores
\begin_inset Quotes erd
\end_inset

 param can also be an array, so you can fire the event on listeners from
 various stores.
 The in-thread store is in 
\begin_inset Quotes eld
\end_inset

Diligence.Events.defaultStores
\begin_inset Quotes erd
\end_inset

, so you can concat that to your custom store if you want to fire the event
 across all stores.
 Or, set 
\begin_inset Quotes eld
\end_inset

Diligence.Events.defaultStore
\begin_inset Quotes erd
\end_inset

 to your own value.
\end_layout

\begin_layout Subsubsection
Persistent Listeners
\end_layout

\begin_layout Standard
In the above example, the listeners would have to be re-subscribed when
 the application restarts, because it cannot guaranteed that application.distribu
tedGlobals would keep its value.
 (Well, you 
\emph on
can
\emph default
 configure Hazelcast to persist the distributedGlobals map\SpecialChar \ldots{}
)
\end_layout

\begin_layout Standard
Let's store our listeners in MongoDB, instead (the default is to use the
 
\begin_inset Quotes eld
\end_inset

events
\begin_inset Quotes erd
\end_inset

 MongoDB collection):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Diligence.Events.subscribe({
\end_layout

\begin_layout Plain Layout

	name: 'payments.successful',
\end_layout

\begin_layout Plain Layout

	stores: new Diligence.Events.MongoDbCollectionStore(),
\end_layout

\begin_layout Plain Layout

	id: 'sendThankYou',
\end_layout

\begin_layout Plain Layout

	dependencies: '/politeness/acknowledgements/',
\end_layout

\begin_layout Plain Layout

	fn: function(name, context) {
\end_layout

\begin_layout Plain Layout

		logger.info('User {0} has paid us {1}!', context.username, context.amount)
\end_layout

\begin_layout Plain Layout

		Acknowledgements.sendThankYou(context.username)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Everything is otherwise the same.
 Neat!
\end_layout

\begin_layout Standard
You can also store events inside a specific, arbitrary MongoDB document,
 using 
\begin_inset CommandInset href
LatexCommand href
name "Savory.Events.MongoDbDocumentStore"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Events.MongoDbDocumentStore"

\end_inset

.
 This is a great way to keep events and their listeners (and the namespace
 for events) localized to a specific object without adding external mechanisms
 and storage.
\end_layout

\begin_layout Standard
Finally, you can create your own custom store class to store events anywhere
 else.
\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
You don't have to configure the Events Service, but it is possible to set
 a few defaults.
 In your application's 
\begin_inset Quotes eld
\end_inset

settings.js
\begin_inset Quotes erd
\end_inset

 add something like this to your app.globals:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.globals = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	savory: {
\end_layout

\begin_layout Plain Layout

		service: {
\end_layout

\begin_layout Plain Layout

			events: {
\end_layout

\begin_layout Plain Layout

				defaultAsync: true,
\end_layout

\begin_layout Plain Layout

				defaultDistributed: true,
\end_layout

\begin_layout Plain Layout

				defaultStores: [function() {
\end_layout

\begin_layout Plain Layout

					document.executeOnce('/savory/service/events/')
\end_layout

\begin_layout Plain Layout

					return new Diligence.Events.MongoDbCollectionStore()
\end_layout

\begin_layout Plain Layout

				}]
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the use of function(): this is required in order to allow the Events
 Service to lazily create the service implementations on demand during runtime.
\end_layout

\begin_layout Section
Forms Service
\end_layout

\begin_layout Standard
Forms are an important feature for any GUI application.
 As for web applications, forms are supported in HTML, but many web applications
 also use JavaScript to send forms to the server in the background (
\begin_inset Quotes eld
\end_inset

AJAX
\begin_inset Quotes erd
\end_inset

).
 Diligence goes a long way towards making it easier for you to use both
 models, each with its own complexities and subtleties, through a unified
 API.
 Allowing for both AJAX and HTML client forms with the same server code
 makes it easy to support 
\begin_inset Quotes eld
\end_inset

legacy
\begin_inset Quotes erd
\end_inset

 clients that can't use AJAX.
\end_layout

\begin_layout Standard
Diligence explicitly supports Ext JS Forms, and recommends Ext JS as a client-si
de framework.
 See the section on Sencha Integration for full details.
\end_layout

\begin_layout Subsubsection
Client-side validation vs.
 server-side validation
\end_layout

\begin_layout Standard
Like all good form frameworks, Diligence's Form Service makes it especially
 makes it easy to implement form validation, both on the server and the
 client, using an extensible system of field types.
 Due to the fact that Diligence is a server-side JavaScript framework, you
 can actually share the exact same validation code on both the client and
 the server! This marvelous advantage makes using forms in Diligence less
 cumbersome as compared to other frameworks.
\end_layout

\begin_layout Standard
What are the advantages of each kind of validation? Why you would want both?
\end_layout

\begin_layout Itemize

\series bold
Server-side validation:
\series default
 You'll at least want this.
 It protects against user error, and can return friendly error codes so
 that the user will know how to correct the form.
 It's also important for security, to make sure that potentially damaging
 data will never enter the other parts of your application.
 For example, you can protect yourself from attacks which try to overflow
 your database with too much data, or attempts at SQL injection.
 (MongoDB injection attacks may be possible, too!) Note also that Diligence
 Forms will automatically catch server-side exceptions, invalidating the
 form and returning the error to the user, but obviously relying on exceptions
 is not secure enough.
\end_layout

\begin_layout Itemize

\series bold
Client-side validation:
\series default
 Adding this to server-side validation will enhance the user experience
 by providing fast, instant feedback, thus avoiding an extra round-trip
 to the server to validate the form data.
 It will also save you some bandwidth and help you scale.
 There are two kinds of client-side validation supported by Diligence, which
 when used together will offer the best user experience:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Validation:
\series default
 The field's whole value will be tested before allowing the form to be submitted.
\end_layout

\begin_layout Itemize

\series bold
Masking:
\series default
 When entering textual data, this locks the user's text field to only accept
 allowed characters.
 For example, if an integer is required, only the characters 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

9
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 (for negative integers) will be allowed.
\end_layout

\end_deeper
\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Forms"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Forms"

\end_inset

.
\end_layout

\begin_layout Standard
Every form is an instance of 
\begin_inset Quotes eld
\end_inset

Diligence.Forms.Form
\begin_inset Quotes erd
\end_inset

 or its subclasses.
 This class inherits 
\begin_inset Quotes eld
\end_inset

Diligence.REST.Resource,
\begin_inset Quotes erd
\end_inset

 and thus can immediately be hooked to your URI-space.
 Indeed, much of the Forms Service power comes from such a setup, so we'll
 go over it here.
 However, note that is also possible to use the form instance without hooking
 it up to a URI, as we'll show in 
\begin_inset Quotes eld
\end_inset

Usage,
\begin_inset Quotes erd
\end_inset

 below.
\end_layout

\begin_layout Standard
First, let's configure the URI-space in your application's 
\begin_inset Quotes eld
\end_inset

routing.js
\begin_inset Quotes erd
\end_inset

.
 Add the following to app.routes and app.dispatchers:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/multiply/': {type: 'implicit', id: 'multiply'}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.dispatchers = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	javascript: {library: '/resources/'}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now configure our resources in 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/forms/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var multiplyForm = {
\end_layout

\begin_layout Plain Layout

	fields: {
\end_layout

\begin_layout Plain Layout

		first: {
\end_layout

\begin_layout Plain Layout

			type: 'number',
\end_layout

\begin_layout Plain Layout

			label: 'A number',
\end_layout

\begin_layout Plain Layout

			required: true
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		second: {
\end_layout

\begin_layout Plain Layout

			type: 'integer',
\end_layout

\begin_layout Plain Layout

			label: 'An integer',
\end_layout

\begin_layout Plain Layout

			required: true
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	process: function(results) {
\end_layout

\begin_layout Plain Layout

		if (results.success) {
\end_layout

\begin_layout Plain Layout

			results.values.result = Number(results.values.first) * Number(results.values.second
)
\end_layout

\begin_layout Plain Layout

			results.msg = '{first} times {second} equals {result}'.cast(results.values)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else {
\end_layout

\begin_layout Plain Layout

			results.msg = 'Invalid!'
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	multiply: new Diligence.Forms.Form(multiplyForm)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's look more closely at this setup below.
\end_layout

\begin_layout Subsubsection
Fields and Validation
\end_layout

\begin_layout Standard
Each field has at least a name (the key in the dict) and a type (defaults
 to 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

).
 If that's all the information you provide, then no validation will occur:
 any value, including an empty value, will be accepted.
\end_layout

\begin_layout Itemize

\series bold
required:
\series default
 The field cannot be empty, neither a null value nor an empty string will
 be accepted.
 Note that the 
\begin_inset Quotes eld
\end_inset

required
\begin_inset Quotes erd
\end_inset

 check happens before the 
\begin_inset Quotes eld
\end_inset

validator
\begin_inset Quotes erd
\end_inset

 function is called.
 [TODO error key]
\end_layout

\begin_layout Itemize

\series bold
validator:
\series default
 A validating function, meant for both client- and server-side validation.
 It 
\emph on
must
\emph default
 return true to signify that the value valid.
 Any other return value will signify invalidity.
 (See 
\begin_inset Quotes eld
\end_inset

validation functions,
\begin_inset Quotes erd
\end_inset

 below.)
\end_layout

\begin_layout Itemize

\series bold
serverValidator:
\series default
 As 
\begin_inset Quotes eld
\end_inset

validator
\begin_inset Quotes erd
\end_inset

, but intended only for server-side validation.
\end_layout

\begin_layout Itemize

\series bold
clientValidator:
\series default
 As 
\begin_inset Quotes eld
\end_inset

validator
\begin_inset Quotes erd
\end_inset

, but intended only for client-side validation.
\end_layout

\begin_layout Itemize

\series bold
mask:
\series default
 A regular expression used for masking.
 This could be JavaScript literal regular expression, a RegExp object, or
 a string.
\end_layout

\begin_layout Itemize

\series bold
serverValidation:
\series default
 Set to false to override the default for the form.
\end_layout

\begin_layout Itemize

\series bold
clientValidation:
\series default
 Set to false to override the default for the form.
\end_layout

\begin_layout Itemize

\series bold
textKeys:
\series default
 An array of text pack keys used by validator function.
 See 
\begin_inset Quotes eld
\end_inset

Text and Internationalization,
\begin_inset Quotes erd
\end_inset

 below.
\end_layout

\begin_layout Itemize

\series bold
type:
\series default
 Instead of providing 
\begin_inset Quotes eld
\end_inset

validator
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

clientValidator
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

serverValidator
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

mask
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

serverValidation
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

clientValidation
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

textKeys
\begin_inset Quotes erd
\end_inset

 for every single field, you can specify a 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 from which these keys will be inherited.
 Defaults to 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

.
 Note that even if you specify 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

, you can override the inherited keys in the field definition.
\end_layout

\begin_layout Itemize

\series bold
value:
\series default
 This is a default value assigned to the field when the form is initialized.
\end_layout

\begin_layout Subsubsection
Validator Functions
\end_layout

\begin_layout Standard
Let's look at such a function in the context of a field definition:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

first: {
\end_layout

\begin_layout Plain Layout

	required: true
\end_layout

\begin_layout Plain Layout

	validator: function(value, field, conversation) {
\end_layout

\begin_layout Plain Layout

		return value % 1 == 0 ? true : 'Must be an integer'
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The return value, as stated before must be true to signify a valid value.
 Otherwise, the value will be considered invalid and the return value will
 be used as the error message.
\end_layout

\begin_layout Standard
The arguments are as follows:
\end_layout

\begin_layout Itemize

\series bold
value:
\series default
 The value to be validated, most likely a string.
\end_layout

\begin_layout Itemize

\series bold
field:
\series default
 The field definition.
 This is useful if you are using the same function for multiple fields,
 and need to validate differently per field.
 Note that the field definition is framework-dependent.
 For example, if you are on the server, it will look like the examples above,
 but if you're on an Ext JS client, then it will use Ext JS's definition.
 Because we're not using 
\begin_inset Quotes eld
\end_inset

field
\begin_inset Quotes erd
\end_inset

 in this example, we supplied just one 
\begin_inset Quotes eld
\end_inset

validator
\begin_inset Quotes erd
\end_inset

 function for both the client and the server.
 However, if you do need to access 
\begin_inset Quotes eld
\end_inset

field
\begin_inset Quotes erd
\end_inset

, it may be better to have separate 
\begin_inset Quotes eld
\end_inset

serverValidator
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

clientValidator
\begin_inset Quotes erd
\end_inset

 functions.
\end_layout

\begin_layout Itemize

\series bold
conversation:
\series default
 The Prudence conversation.
 Only available on the server.
\end_layout

\begin_layout Standard
The function is called with an implicit 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 object, which obviously refers to different objects on the server and the
 client, but you can expect these fields:
\end_layout

\begin_layout Itemize

\series bold
form:
\series default
 The form instance.
 Only available on the server.
\end_layout

\begin_layout Itemize

\series bold
textPack:
\series default
 The currently used text pack.
 Always available on the server, and available on some clients, such as
 Ext JS if you use Diligence's Sencha Integration.
 See 
\begin_inset Quotes eld
\end_inset

Text and Internationalization,
\begin_inset Quotes erd
\end_inset

 below, for more information.
\end_layout

\begin_layout Standard
Through accessing the 
\begin_inset Quotes eld
\end_inset

field
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

conversation
\begin_inset Quotes erd
\end_inset

 arguments as well as 
\begin_inset Quotes eld
\end_inset

this.form
\begin_inset Quotes erd
\end_inset

, you can do some very sophisticated server-side validation.
 For example, you can query MongoDB and check against data, check for security
 authorization, etc.
 And, of course, you can use similar sophistication for client-side frameworks
 according to the features they provide.
\end_layout

\begin_layout Standard
(At this point, you might be wondering how exactly client-side validator
 functions get to be called on the client, since we are defining them on
 the server.
 We'll talk about that in 
\begin_inset Quotes eld
\end_inset

Usage,
\begin_inset Quotes erd
\end_inset

 below, but the solution is simple: we send the source code directly as
 text!)
\end_layout

\begin_layout Subsubsection
Types
\end_layout

\begin_layout Standard
The Forms Service comes with a few basic types to get you started, all defined
 under 
\begin_inset Quotes eld
\end_inset

Diligence.Forms.Types
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize

\series bold
string:
\series default
 All values are valid.
 This is the default type.
\end_layout

\begin_layout Itemize

\series bold
number:
\series default
 Valid if the value can be converted into a JavaScript number.
 Masked for digits, 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
integer:
\series default
 Valid if the value can be converted into a JavaScript integer.
 Masked for digits and 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
email:
\series default
 Valid if the value is a standard email address.
 Does no masking.
\end_layout

\begin_layout Itemize

\series bold
recaptcha:
\series default
 See reCAPTCHA.
\end_layout

\begin_layout Standard
You can also provide your own types:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var serviceForm = {
\end_layout

\begin_layout Plain Layout

	types: {
\end_layout

\begin_layout Plain Layout

		bool: {
\end_layout

\begin_layout Plain Layout

			validator: function(value, field, conversation) {
\end_layout

\begin_layout Plain Layout

				value = String(value).toLowerCase()
\end_layout

\begin_layout Plain Layout

				return (value == 'true') || (value == 'false')
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	fields: {
\end_layout

\begin_layout Plain Layout

		enabled: {
\end_layout

\begin_layout Plain Layout

			type: 'bool',
\end_layout

\begin_layout Plain Layout

			label: 'Whether the service is enabled'
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Text and Internationalization
\end_layout

\begin_layout Standard
If you don't need internationalization, then just use the 
\begin_inset Quotes eld
\end_inset

label
\begin_inset Quotes erd
\end_inset

 key in the field definition to set up the text directly.
 If unspecified, it will default to the field name.
\end_layout

\begin_layout Standard
Otherwise, read about the Diligence Internationalization Service to understand
 how to set it up.
 We will use the 
\begin_inset Quotes eld
\end_inset

labelKey
\begin_inset Quotes erd
\end_inset

 key instead of 
\begin_inset Quotes eld
\end_inset

label
\begin_inset Quotes erd
\end_inset

, and also set up the list of other keys we might need using the 
\begin_inset Quotes eld
\end_inset

textKeys
\begin_inset Quotes erd
\end_inset

 key:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

first: {
\end_layout

\begin_layout Plain Layout

	labelKey: 'myapp.myform.field.first',
\end_layout

\begin_layout Plain Layout

	textKeys: ['myapp.myform.validation.integer.not'],
\end_layout

\begin_layout Plain Layout

	required: true
\end_layout

\begin_layout Plain Layout

	validator: function(value, field, conversation) {
\end_layout

\begin_layout Plain Layout

		return value % 1 == 0 ? true : this.textPack.get('myapp.myform.validation.integer.no
t')
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above code will work on both the client and the server, because 
\begin_inset Quotes eld
\end_inset

textKeys
\begin_inset Quotes erd
\end_inset

 ensures that all those text values are sent to the client.
\end_layout

\begin_layout Subsubsection
Processing
\end_layout

\begin_layout Standard
Let's look at our processing function again:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

process: function(results) {
\end_layout

\begin_layout Plain Layout

	if (results.success) {
\end_layout

\begin_layout Plain Layout

		results.values.result = Number(results.values.first) * Number(results.values.second)
\end_layout

\begin_layout Plain Layout

		results.msg = '{first} times {second} equals {result}'.cast(results.values)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else {
\end_layout

\begin_layout Plain Layout

		results.msg = 'Invalid!'
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function will be called after validation happens, with 
\begin_inset Quotes eld
\end_inset

results
\begin_inset Quotes erd
\end_inset

 being a pre-defined dict, ready for you to modify, with the following keys:
\end_layout

\begin_layout Itemize

\series bold
results.success:
\series default
 Will be true if the form data is valid.
 You can change it to false during processing in order to signify an error
 to the user.
 Exceptions thrown in this function will also cause 
\begin_inset Quotes eld
\end_inset

results.success
\begin_inset Quotes erd
\end_inset

 to be false.
\end_layout

\begin_layout Itemize

\series bold
results.values:
\series default
 A dict of the form values sent from the user.
 The value keys correspond to the field keys.
 Note that 
\begin_inset Quotes eld
\end_inset

results.values
\begin_inset Quotes erd
\end_inset

 will be deleted if 
\begin_inset Quotes eld
\end_inset

results.success
\begin_inset Quotes erd
\end_inset

 is true.
 The reason is that you should only need the old values if the user needs
 to correct the form in case of an error.
 If the form was successful, the form values should be reset.
 (In the example above we are setting 
\begin_inset Quotes eld
\end_inset

results.values.result
\begin_inset Quotes erd
\end_inset

 only for the purpose of the string template cast.)
\end_layout

\begin_layout Itemize

\series bold
results.msg:
\series default
 A message to be displayed to the user.
\end_layout

\begin_layout Itemize

\series bold
results.errors:
\series default
 A dict of error messages per field, as set by the field validator functions.
 The error keys correspond to the field keys.
 This dict will not exist if 
\begin_inset Quotes eld
\end_inset

results.success
\begin_inset Quotes erd
\end_inset

 is true when this function is called.
\end_layout

\begin_layout Standard
As stated, you can modify any of these results as you need, including settings
 
\begin_inset Quotes eld
\end_inset

results.errors
\begin_inset Quotes erd
\end_inset

 to extra per-field error messages, beyond what was performed in validation.
 
\end_layout

\begin_layout Standard
Indeed, you can use the processing function to do extra validation, which
 might have to take into consideration the form as a whole, rather than
 individual fields.
 For example, what if a start-date field in the form is set to be after
 an end-date field? You can find that out here and set 
\begin_inset Quotes eld
\end_inset

results.success
\begin_inset Quotes erd
\end_inset

 to false, with 
\begin_inset Quotes eld
\end_inset

results.errors.endDate
\begin_inset Quotes erd
\end_inset

 to a suitable error message.
\end_layout

\begin_layout Standard
The return value of this function is ignored.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
If you've set up the resource as instructed above, you should be able to
 access it at the specified URI.
 By default, it will only support the HTTP POST operation, for which it
 expects an entity in the 
\begin_inset Quotes eld
\end_inset

application/x-www-form-urlencoded
\begin_inset Quotes erd
\end_inset

 media type, as is used by HTML forms.
\end_layout

\begin_layout Standard
Later on, we'll show you below how the Forms Service can help you render
 an HTML form, complete with validation error messages and internationalization
 support.
\end_layout

\begin_layout Subsubsection
HTML Forms
\end_layout

\begin_layout Standard
For now, let's just start with a straightforward, literal HTML example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

<form action="<%= conversation.pathToBase + '/multiply/?mode=redirect' %>"
 method="post">
\end_layout

\begin_layout Plain Layout

	<p>First value: <input name="first" /></p>
\end_layout

\begin_layout Plain Layout

	<p>Second value: <input name="second" /></p>
\end_layout

\begin_layout Plain Layout

	<p><input type="submit" value="Multiply!" /></p>
\end_layout

\begin_layout Plain Layout

</form>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll notice that added a 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 query parameter to the action URI.
 This lets us select one of the following modes of behavior supported by
 the resource:
\end_layout

\begin_layout Itemize

\series bold
json:
\series default
 This is the mode you'll want to use for AJAX, as it returns the form results
 in JSON format.
 JSON mode additionally supports the 
\begin_inset Quotes eld
\end_inset

human=true
\begin_inset Quotes erd
\end_inset

 query parameter to return the JSON in multiline, indented format.
 
\emph on
Note that this is the default mode.
\end_layout

\begin_layout Itemize

\series bold
redirect:
\series default
 After processing, the resource will redirect the client to a new URI.
 The default is the sending URI, but you can set up specific URIs for success
 and failure.
\end_layout

\begin_layout Itemize

\series bold
capture:
\series default
 As an alternative to a redirect, you can perform a Prudence 
\begin_inset Quotes eld
\end_inset

capture
\begin_inset Quotes erd
\end_inset

 of another internal URI.
 The user will see the URI of the form resource itself, but the content
 will come from elsewhere.
 Note that because capturing happens in the same conversation, without a
 round trip to the client, you can use all the data used during processing.
 If you do a redirect, the client would be sending a new request and that
 data would be gone.
\end_layout

\begin_layout Standard
When creating your resource instance, you can change the default to be something
 other than 
\begin_inset Quotes eld
\end_inset

json
\begin_inset Quotes erd
\end_inset

 by setting the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 key.
 JSON was chosen as a default because it's easiest to test and produces
 the least amount of side-effects due to unintentional access to the resource.
\end_layout

\begin_layout Subsubsection
Testing Your Form Resource with cURL
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "cURL"
target "http://curl.haxx.se/"

\end_inset

 is an HTTP command line tool based on the cURL library, available for a
 great many Unix-like operating systems as well as Windows.
 It's especially useful for testing RESTful APIs.
 Here's a quick tutorial to get you started with using cURL with the Forms
 Service.
\end_layout

\begin_layout Standard
Try this command to send a POST to your form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl --data-urlencode first=5 --data-urlencode second=6 "http://localhost:8080/m
yapp/multiply/?human=true"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that using the 
\begin_inset Quotes eld
\end_inset

data-urlencode
\begin_inset Quotes erd
\end_inset

 switch will automatically set the method to POST and the entity type to
 
\begin_inset Quotes eld
\end_inset

application/x-www-form-urlencoded.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Because the resource's default mode is JSON, you should get this result:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"success": true,
\end_layout

\begin_layout Plain Layout

	"msg": "5 times 6 equals 30"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you're using AJAX to POST to the resource, then you'll have to parse
 these JSON results accordingly.
 See 
\begin_inset Quotes eld
\end_inset

Processing
\begin_inset Quotes erd
\end_inset

 above for the exact format of the results.
\end_layout

\begin_layout Standard
Also note that this format is immediately usable by Ext JS forms! See Diligence'
s Ext JS Integration for more details.
\end_layout

\begin_layout Standard
You can also use cURL to test redirect mode:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl -v -e "http://my-referring-url" --data-urlencode first=5 --data-urlencode
 second=6 "http://localhost:8080/myapp/multiply/?mode=redirect"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You should see the redirected URL in the 
\begin_inset Quotes eld
\end_inset

Location
\begin_inset Quotes erd
\end_inset

 header, as well as an HTTP status of 303.
\end_layout

\begin_layout Subsubsection
Redirect Mode
\end_layout

\begin_layout Standard
Redirect mode will by default redirect the client to the referring URI,
 using HTTP status 303 (
\begin_inset Quotes eld
\end_inset

See Other
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
But, you can explicitly set the redirection URI to something specific in
 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var multiplyForm = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	redirectUri: '/multiply/results/',
\end_layout

\begin_layout Plain Layout

	mode: 'redirect' // we'll make this the default mode (instead of 'json')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also set 
\begin_inset Quotes eld
\end_inset

redirectSuccessUri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

redirectFailureUri
\begin_inset Quotes erd
\end_inset

 separately.
\end_layout

\begin_layout Standard
Or, you can set the URI dynamically by setting 
\begin_inset Quotes eld
\end_inset

results.redirect
\begin_inset Quotes erd
\end_inset

 in your processing function.
\end_layout

\begin_layout Standard
This should go without saying, but client redirections means that a whole
 new HTTP GET request will be sent by the client, such that all your conversatio
n data will be gone.
 Of course, often the resulting page should depend on the result of form
 processing.
 There are two good strategies for handling this:
\end_layout

\begin_layout Itemize
Because you can set the URI dynamically in 
\begin_inset Quotes eld
\end_inset

results.redirect
\begin_inset Quotes erd
\end_inset

, you can create a special kind of results view.
 For example, let's say you are implementing a search form (like Google's
 search engine page), which should redirect the user to the search results.
 You could redirect to a URI which includes the search results, for example
 in the URI query string.
 For example, searching for the phrase 
\begin_inset Quotes eld
\end_inset

cool apps
\begin_inset Quotes erd
\end_inset

 could end up redirecting to something like this: 
\begin_inset Quotes eld
\end_inset

http://myapp.org/search/?terms=cool+apps
\begin_inset Quotes erd
\end_inset

.
 In 
\begin_inset Quotes eld
\end_inset

/mapped/search.d.html
\begin_inset Quotes erd
\end_inset

 you would then unpack the terms and display the correct results.
 (You likely want to cache the search results for a while for the best user
 experience!)
\end_layout

\begin_layout Itemize
Another option is set a cookie, using Prudence's 
\begin_inset Quotes eld
\end_inset

conversation.createCookie
\begin_inset Quotes erd
\end_inset

 API, which you can then read in the redirected page using 
\begin_inset Quotes eld
\end_inset

conversation.cookies
\begin_inset Quotes erd
\end_inset

.
 Cookies are great if the result is very specific to the user, but note
 that bookmarks to the result URL would display something different if the
 cookie does not exist.
\end_layout

\begin_layout Subsubsection
Capture Mode
\end_layout

\begin_layout Standard
Capture mode may seem similar to redirect mode: you supply a new URI which
 gets displayed to the client.
 The difference is that 
\begin_inset Quotes eld
\end_inset

redirection
\begin_inset Quotes erd
\end_inset

 happens on the server, rather than the client.
 That means that the URI for the client will remain the same.
 This is more efficient in that an extra round trip from the client is avoided.
 However, it creates serious problems for bookmarking: the result URI ends
 up being the same as the form URI.
 Think carefully about the pros and cons of each approach in terms of what
 would provide the best user experience.
 (Also see manual mode, below, which is similar in behavior to capture mode.)
\end_layout

\begin_layout Standard
You can access the form and the captured page using 
\begin_inset Quotes eld
\end_inset

Diligence.Forms.getCapturedForm
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Diligence.Forms.getCapturedResults
\begin_inset Quotes erd
\end_inset

.
 This API will only work in a captured page.
 Let's see how this works by creating a 
\begin_inset Quotes eld
\end_inset

/mapped/multiply/results.d.html
\begin_inset Quotes erd
\end_inset

 for our results:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/forms/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var form = Diligence.Forms.getCapturedForm(conversation)
\end_layout

\begin_layout Plain Layout

var results = Diligence.Forms.getCapturedResults(conversation)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (results && results.success) {
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

<p><%= results.msg %></p>
\end_layout

\begin_layout Plain Layout

<% } else { %>
\end_layout

\begin_layout Plain Layout

<form method="post">
\end_layout

\begin_layout Plain Layout

	<p>First value: <input name="first" /></p>
\end_layout

\begin_layout Plain Layout

	<p>Second value: <input name="second" /></p>
\end_layout

\begin_layout Plain Layout

	<p><input type="submit" value="Multiply!" /></p>
\end_layout

\begin_layout Plain Layout

</form>
\end_layout

\begin_layout Plain Layout

<% } %>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can specify the capture URI when we create the resource, in 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var multiplyForm = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	captureUri: '/multiply/results/',
\end_layout

\begin_layout Plain Layout

	mode: 'capture' // we'll make this the default mode (instead of 'json')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also set 
\begin_inset Quotes eld
\end_inset

captureSuccessUri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

captureFailureUri
\begin_inset Quotes erd
\end_inset

 separately.
\end_layout

\begin_layout Standard
Or, you can set the URI dynamically by setting 
\begin_inset Quotes eld
\end_inset

results.capture
\begin_inset Quotes erd
\end_inset

 in your processing function.
\end_layout

\begin_layout Standard
Finally, while it's not entirely necessary, you can hide the URI.
 This will guarantee that it's only available for capturing, but the user
 won't be able to reach it by entering the URL in their browser.
 You do this in your application's 
\begin_inset Quotes eld
\end_inset

routing.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/multiply/results/': 'hidden'
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Manual Mode
\end_layout

\begin_layout Standard
If you go back to the code for the simple HTML form we've provided above,
 you might wonder if having the form as a separate resource is necessary.
 While it does provide a cleaner separation between the form processing
 resource and the HTML view resource, it would be more efficient if we could
 avoid that extra client redirect and do the processing and viewing in the
 same resource.
\end_layout

\begin_layout Standard
Before we consider if this is a good idea or not, let's see how this would
 be easily done with Diligence:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/forms/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var form = Diligence.Forms.getForm('/multiply/')
\end_layout

\begin_layout Plain Layout

var results = form.handle(conversation)
\end_layout

\begin_layout Plain Layout

if (results && results.success) {
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

<p><%= results.msg %></p>
\end_layout

\begin_layout Plain Layout

<% } else { %>
\end_layout

\begin_layout Plain Layout

<form method="post">
\end_layout

\begin_layout Plain Layout

	<p>First value: <input name="first" /></p>
\end_layout

\begin_layout Plain Layout

	<p>Second value: <input name="second" /></p>
\end_layout

\begin_layout Plain Layout

	<p><input type="submit" value="Multiply!" /></p>
\end_layout

\begin_layout Plain Layout

</form>
\end_layout

\begin_layout Plain Layout

<% } %>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A few points to explain:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Diligence.Forms.getForm
\begin_inset Quotes erd
\end_inset

 is a very useful function.
 It works by doing an internal GET on the URI to fetch the form instance.
 We could have also avoided setting up the instance in 
\begin_inset Quotes eld
\end_inset

resources.js
\begin_inset Quotes erd
\end_inset

 as well as routing it in 
\begin_inset Quotes eld
\end_inset

routing.js
\begin_inset Quotes erd
\end_inset

, and instead simply have created the 
\begin_inset Quotes eld
\end_inset

Diligence.Forms.Form
\begin_inset Quotes erd
\end_inset

 instance here.
 But this lets us use the instance both as a resource and in manual mode,
 as we've done here.
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

handle
\begin_inset Quotes erd
\end_inset

 method will validate and process the form, but only if the conversation
 is a POST.
 If it's not processed, it will will return null.
\end_layout

\begin_layout Itemize
Note how we're displaying different content according to whether the processing
 was successful or not.
\end_layout

\begin_layout Standard
So, is manual mode a good idea or not? If can provide a straightforward,
 quick-and-dirty way to implement a form.
 Compact, too: you can create the instance, do all the processing, and put
 all the view code in a single file.
 There's no need to set up routing for a resource.
\end_layout

\begin_layout Standard
But, there are a few disadvantages:
\end_layout

\begin_layout Itemize
The code is not very easy to follow or debug.
 The same page is doing three different things: 1) displaying the form,
 2) displaying errors, and 3) displaying the results of a successful post.
 (You could put each view in a different included fragment, but would lose
 the compactness.)
\end_layout

\begin_layout Itemize
This also means that caching logic for the page my be difficult if not impossibl
e to do efficiently.
\end_layout

\begin_layout Itemize
A single URI with multiple uses can be confusing for users.
 If they bookmark the result 
\begin_inset Quotes eld
\end_inset

page,
\begin_inset Quotes erd
\end_inset

 but try to go to it again at a later time, it would display an unfilled
 form, because it's the same page.
 This is problematic for all POSTed HTML forms: it's always a good idea
 to redirect the user to a book-markable URI that responds correctly to
 an HTTP GET.
\end_layout

\begin_layout Standard
You can mitigate some of these problems by using capture mode instead.
 Capture mode will let you use a separate page for results, which can be
 cached (on the server, at least: a POST will never cache on the client),
 while keeping the URI the same.
\end_layout

\begin_layout Subsubsection
Low-Level Manual Mode
\end_layout

\begin_layout Standard
So, this 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 actually does not use the Diligence Forms Service at all, instead it relies
 directly on the Prudence API.
 We thought it would be a good idea to include it here for the sake of completio
n.
 Sometimes, even manual mode may not be quick-and-dirty enough! Note that
 validation is very, very basic: if the value cannot be converted, you will
 simply get a null.
\end_layout

\begin_layout Standard
Here's how it would look:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/prudence/resources/')
\end_layout

\begin_layout Plain Layout

document.executeOnce('/sincerity/objects/')
\end_layout

\begin_layout Plain Layout

document.executeOnce('/sincerity/templates/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var form
\end_layout

\begin_layout Plain Layout

if (conversation.request.method.name == 'POST') {
\end_layout

\begin_layout Plain Layout

	form = Prudence.Resources.getForm(conversation, {
\end_layout

\begin_layout Plain Layout

		first: 'float',
\end_layout

\begin_layout Plain Layout

		second: 'int'
\end_layout

\begin_layout Plain Layout

	})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (form && Sincerity.Objects.exists(form.first) && Sincerity.Objects.exists(form.seco
nd)) {
\end_layout

\begin_layout Plain Layout

	form.result = Number(form.first) * Number(form.second)
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

<p><%= '{first} times {second} equals {result}'.cast(form) %></p>
\end_layout

\begin_layout Plain Layout

<% } else { %>
\end_layout

\begin_layout Plain Layout

<form method="post">
\end_layout

\begin_layout Plain Layout

	<p>First value: <input name="first" /></p>
\end_layout

\begin_layout Plain Layout

	<p>Second value: <input name="second" /></p>
\end_layout

\begin_layout Plain Layout

	<p><input type="submit" value="Multiply!" /></p>
\end_layout

\begin_layout Plain Layout

</form>
\end_layout

\begin_layout Plain Layout

<% } %>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rendering an Internationalized HTML Form
\end_layout

\begin_layout Standard
In all the above examples, we explicitly entered the HTML for the form and
 its fields.
 But, Diligence Forms can also generate the HTML for you, and moreover use
 the Internationalization Service, in conjunction with the Authorization
 Service, to render the correct text for the user's preferred language.
\end_layout

\begin_layout Standard
The rendered HTML is very straightforward: it's a simple <input> tag when
 using 
\begin_inset Quotes eld
\end_inset

htmlText
\begin_inset Quotes erd
\end_inset

 (or a <textarea> tag when usng 
\begin_inset Quotes eld
\end_inset

htmlTextArea
\begin_inset Quotes erd
\end_inset

), with a connected <label> prepended.
 If the field failed validation then an extra <div> is appended with the
 validation error message.
 Furthermore, in case of validation error, all tags for the field will get
 the 
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

 class, allowing you to use CSS in order to stylize validation errors.
\end_layout

\begin_layout Standard
You should add the 
\begin_inset Quotes eld
\end_inset

results
\begin_inset Quotes erd
\end_inset

 of the form if you have them (they are available in capture mode and manual
 mode) to the method calls.
 This will render errors properly, and also set the values of the form to
 the previous values, making it easier for the user to correct the form.
\end_layout

\begin_layout Standard
Here's an example using manual mode, which also uses CSS to stylize form
 errors:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<head>
\end_layout

\begin_layout Plain Layout

<style>
\end_layout

\begin_layout Plain Layout

form input.error {
\end_layout

\begin_layout Plain Layout

	border: 1px solid red;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

form div.error {
\end_layout

\begin_layout Plain Layout

	color: red;
\end_layout

\begin_layout Plain Layout

	display: inline;
\end_layout

\begin_layout Plain Layout

	padding-left: 5px;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

</style>
\end_layout

\begin_layout Plain Layout

</head>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/forms/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var form = Diligence.Forms.getForm('/multiply/')
\end_layout

\begin_layout Plain Layout

var results = form.handle(conversation)
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

<form method="post">
\end_layout

\begin_layout Plain Layout

	<div><%= form.htmlText({name: 'first', conversation: conversation, results:
 results}) %></div>
\end_layout

\begin_layout Plain Layout

	<div><%= form.htmlText({name: 'second', conversation: conversation, results:
 results}) %></div>
\end_layout

\begin_layout Plain Layout

	<div><input type="submit" value="Multiply!" /></div>
\end_layout

\begin_layout Plain Layout

</form>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Section
HTML Service
\end_layout

\begin_layout Standard
This straightforward service generates unique integers in a series, using
 MongoDB atomic operations.
 No number in a specific series will ever be generated again.
 This service is thus useful for generating integer IDs.
\end_layout

\begin_layout Standard
Note that uniqueness is only guaranteed by the intactness of the MongoDB
 database.
 If you somehow lose it and have to start over, there's a chance you would
 regenerate IDs that have already been used.
 If you need unique IDs that don't have this limitation, you'll want to
 use GUIDs instead.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.HTML"
target "http://threecrickets.com/javascript-api/?namespace=Savory.HTML"

\end_inset

.
\end_layout

\begin_layout Section
Internationalization Service
\end_layout

\begin_layout Standard
This is a straightforward but powerful service that lets you render text
 by key from 
\begin_inset Quotes eld
\end_inset

text packs
\begin_inset Quotes erd
\end_inset

 per locale.
\end_layout

\begin_layout Standard
A single application can load many text packs simultaneously, such that
 every user could see text in their preferred language, if you support it.
 Text packs can be cached in memory (in the application globals) once loaded,
 while giving you control over the cache duration in case you want to enable
 on-the-fly editing of text packs.
\end_layout

\begin_layout Standard
Importantly, this service supports bi-directionality (left-to-right or right-to-
left languages) by keeping track of the direction of 
\emph on
every single key
\emph default
.
 This is crucial, because you may have to render left-to-right and right-to-left
 text on the same page, on you want to make sure that each key is rendered
 correctly.
\end_layout

\begin_layout Standard
Text packs can inherit each other, making it easy to manage many text packs
 with a common base, or to merge text packs from different sources into
 one.
 For example, you can you have a general English text pack, and the a British
 English text pack, which inherits the general English text pack and only
 overrides those keys that are different.
 Directionality of keys is maintained: if a right-to-left Arabic text pack
 inherits an English text pack, those left-to-right keys from the English
 text pack will stay left-to-right.
\end_layout

\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
Text packs are looked for first JSON files and then in a MongoDB collection
 called 
\begin_inset Quotes eld
\end_inset

textpacks
\begin_inset Quotes erd
\end_inset

.
 You can combine text packs from both, and inherit either from the other.
\end_layout

\begin_layout Standard
The text pack is a dict that must include at least a 
\begin_inset Quotes eld
\end_inset

text
\begin_inset Quotes erd
\end_inset

 key, with a structure of any depth, and optionally a 
\begin_inset Quotes eld
\end_inset

direction
\begin_inset Quotes erd
\end_inset

 key, which could be either 
\begin_inset Quotes eld
\end_inset

ltr
\begin_inset Quotes erd
\end_inset

 (the default, for left-to-right, the default), or 
\begin_inset Quotes eld
\end_inset

rtl
\begin_inset Quotes erd
\end_inset

 (for right-to-left languages).
 Additionally, you can add an 
\begin_inset Quotes eld
\end_inset

inherits
\begin_inset Quotes erd
\end_inset

 key, which can be either a single locale specification or an array of locale
 specifications, which specifies which text packs should be merged into
 this one.
 The values of the inheriting text pack will always override those from
 the inherited text packs.
\end_layout

\begin_layout Subsubsection
Locale Specifications
\end_layout

\begin_layout Standard
In all the following examples, whenever you need to specify a locale you
 can specify it either as a string signifying the language or in full form,
 with 
\begin_inset Quotes eld
\end_inset

language
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

country
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

variant
\begin_inset Quotes erd
\end_inset

 keys.
 For example, these two locale specifications would be considered equivalent:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

"en" == {"language": "en"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But this locale would be different:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{"language": "en", "country": "nz"}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
As MongoDB Documents
\end_layout

\begin_layout Standard
Text packs will be found in the collection called 
\begin_inset Quotes eld
\end_inset

textpacks
\begin_inset Quotes erd
\end_inset

.
 They have the same structure as the JSON files, but must also have a 
\begin_inset Quotes eld
\end_inset

locale
\begin_inset Quotes erd
\end_inset

 key, with the locale specification as detailed above.
 Here's an example document:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	_id: ObjectId("4d6803e6ddfe99e799c7b809"),
\end_layout

\begin_layout Plain Layout

	"locale": {
\end_layout

\begin_layout Plain Layout

		"language": "en",
\end_layout

\begin_layout Plain Layout

		"country": "nz"
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"direction": "ltr",
\end_layout

\begin_layout Plain Layout

	"inherit": "en",
\end_layout

\begin_layout Plain Layout

	"text": {
\end_layout

\begin_layout Plain Layout

		"application": {
\end_layout

\begin_layout Plain Layout

			"myapp": {
\end_layout

\begin_layout Plain Layout

				"time": "It is now {now}"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again we'll emphasize: even though this text pack is defined in MongoDB,
 it can inherit the 
\begin_inset Quotes eld
\end_inset

en
\begin_inset Quotes erd
\end_inset

 text pack defined in the JSON file.
\end_layout

\begin_layout Standard
You'll usually prefer one method or the other, but it might make sense to
 use both: for example, a default text pack can be hard-coded for your applicati
on, to allow it to function even if MongoDB is not available.
\end_layout

\begin_layout Subsubsection
As JSON Files
\end_layout

\begin_layout Standard
If stored in files, the name of the file must be in the form 
\begin_inset Quotes eld
\end_inset

[locale].json
\begin_inset Quotes erd
\end_inset

.
 For example, for the English locale it is 
\begin_inset Quotes eld
\end_inset

en.json
\begin_inset Quotes erd
\end_inset

.
 If the locale has country and variant specifications, they are added with
 underscores.
 For example, English/New Zealand would be 
\begin_inset Quotes eld
\end_inset

en_nz.json
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
An example 
\begin_inset Quotes eld
\end_inset

en.json
\begin_inset Quotes erd
\end_inset

 file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"direction": "ltr",
\end_layout

\begin_layout Plain Layout

	"text": {
\end_layout

\begin_layout Plain Layout

		"application": {
\end_layout

\begin_layout Plain Layout

			"myapp": {
\end_layout

\begin_layout Plain Layout

				"time": "It is now {now}"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Per-User Text Packs
\end_layout

\begin_layout Standard
See the 
\begin_inset Quotes eld
\end_inset

Authentication Service.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Internationalization"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Internationalization"

\end_inset

.
\end_layout

\begin_layout Standard
Here's an example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/internationalization/')
\end_layout

\begin_layout Plain Layout

var textPack = Diligence.Internationalization.getPack('en')
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

<p dir="<%= textPack.getDirection('application.myapp.time') %>">
\end_layout

\begin_layout Plain Layout

	<%= textPack.get('application.myapp.time', {now: new Date()}) %>
\end_layout

\begin_layout Plain Layout

</p>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var textPack = Diligence.Internationalization.getCurrentPack(conversation)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

get
\begin_inset Quotes erd
\end_inset

 method will automatically cast templates.
 In this case, our text is a template in the form of 
\begin_inset Quotes eld
\end_inset

It is now {now}
\begin_inset Quotes erd
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

getDirection
\begin_inset Quotes erd
\end_inset

 method will return either 
\begin_inset Quotes eld
\end_inset

ltr
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

rtl
\begin_inset Quotes erd
\end_inset

 according to the directionality of that specific key.
\end_layout

\begin_layout Subsubsection
Attaching a Text Pack to the Conversation
\end_layout

\begin_layout Standard
In many cases, you would not want to specify the locale explicitly, but
 instead would want it loaded from, say, the logged-in user's stored preferences.
 In that case, you can store the selected locale in the conversation.locals
 as 
\begin_inset Quotes eld
\end_inset

savory.service.internationalization.pack
\begin_inset Quotes erd
\end_inset

, or use this shortcut:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

textPack.setCurrent(conversation)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And then retrieve it like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var textPack = Diligence.Internationalization.getCurrentPack(conversation)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many of Diligence's other services and features rely on this API call, so
 make sure to set up the conversation.local appropriately if you want them
 to support internationalization.
\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
In your application's 
\begin_inset Quotes eld
\end_inset

settings.js
\begin_inset Quotes erd
\end_inset

, add something like this to your app.globals:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.globals = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	savory: {
\end_layout

\begin_layout Plain Layout

		service: {
\end_layout

\begin_layout Plain Layout

			internationalization: {
\end_layout

\begin_layout Plain Layout

				defaultLocale: 'en',
\end_layout

\begin_layout Plain Layout

				cacheDuration: 10000, // in milliseconds; if 0 (the default) will never
 cache
\end_layout

\begin_layout Plain Layout

				path: Sincerity.Container.getFileFromHere('textpacks') // optional
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It would then look for 
\begin_inset Quotes eld
\end_inset

.json
\begin_inset Quotes erd
\end_inset

 files in the 
\begin_inset Quotes eld
\end_inset

/textpacks/
\begin_inset Quotes erd
\end_inset

 directory under your application's main directory.
\end_layout

\begin_layout Standard
To signify the locale in full form during configuration, make sure to use
 the 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 key to avoid flattening of the dict (see Sincerity.Objects.flatten).
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

defaultLocale: {.: {language: 'en', country: 'nz'}}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Cache Service
\end_layout

\begin_layout Standard
The Prudence platform already provides excellent caching for your generated
 HTML, with a lot of control over cache keys.
 It also provides you with an API to access the cache backend directly.
 But, that is a very special purpose cache highly optimized for that particular
 task.
\end_layout

\begin_layout Standard
With the Diligence Cache Service, we are providing you with a general purpose
 caching mechanism, letting you store anything MongoDB can take, again with
 full control over key generation.
 Moreover, the Cache Service lets you easily wrap arbitrary JavaScript functions
, so that you can transparently cache their results.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Cache"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Cache"

\end_inset

.
\end_layout

\begin_layout Standard
A simple example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/cache/')
\end_layout

\begin_layout Plain Layout

document.executeOnce('/sincerity/jvm/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var cache = new Diligence.Cache('result')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var getResult = function(userId) {
\end_layout

\begin_layout Plain Layout

	Sincerity.JVM.sleep(1000)
\end_layout

\begin_layout Plain Layout

	return {
\end_layout

\begin_layout Plain Layout

		userId: userId,
\end_layout

\begin_layout Plain Layout

		randomValue: Math.random()
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

.cache(cache, 10000, 'result.')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var result = getResult(123)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A few notes:
\end_layout

\begin_layout Itemize
Our 
\begin_inset Quotes eld
\end_inset

getResult
\begin_inset Quotes erd
\end_inset

 function here is very silly, and purposely delays for 1 second.
 However, it could easily do very real things: for example, a slow map-reduce
 query on MongoDB, fetching data from an external service or site, etc.
\end_layout

\begin_layout Itemize
We here cache the result for 10 seconds, meaning that only once every 10
 seconds would the function actually be called.
 In all other cases, the last cached result will be retrieved from the MongoDB
 collection.
 It should go without saying, but: this works in high-concurrency, so any
 number of threads and nodes would be using the same cached value.
\end_layout

\begin_layout Itemize
The data must be compatible with MongoDB.
 This includes anything that works with MongoDB's extended JSON format.
\end_layout

\begin_layout Itemize
We here use a simple string prefix (
\begin_inset Quotes eld
\end_inset

result.
\begin_inset Quotes erd
\end_inset

) to generate our cache key.
 The service will automatically add the function arguments to the cache
 key, so in this case our cache key will be 
\begin_inset Quotes eld
\end_inset

result.123
\begin_inset Quotes erd
\end_inset

.
 However, you can supply a function instead of a string, which would return
 the final cache key as the string using whatever logic you need.
 An implication of this is that you can use a single cache collection to
 store results of numerous functions, as long as you make sure that the
 final cache keys don't overlap.
\end_layout

\begin_layout Itemize
The library overrides the JavaScript function prototype, adding the 
\begin_inset Quotes eld
\end_inset

cache
\begin_inset Quotes erd
\end_inset

 method to it.
 The Diligence.Cache API also has methods that offer more flexibility.
 For example, it can let you set advanced logging, so that you can see how
 the cache is working.
 See the API documentation for full details.
\end_layout

\begin_layout Itemize
The service removes expired entries only when you try to access them.
 If it's important for you to save space and remove 
\emph on
all
\emph default
 expired cache entries, you might want to call the Diligence.Cache.prune method
 regularly.
 You can do this in your 
\begin_inset Quotes eld
\end_inset

crontab
\begin_inset Quotes erd
\end_inset

 file.
 Here's an example of doing so every 15 minutes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

*/15 * * * * <% document.executeOnce('/savory/service/cache/'); new Diligence.Cach
e('result').prune(); %>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Linkback Service
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Linkbacks
\begin_inset Quotes erd
\end_inset

 are a way to add cross-referencing to hyperlinks: if I link to another
 page on another site, I can let that other site know that I am linking
 to it, and then that other site can choose to display a link back to my
 site.
 This can be useful for users, as it lets them quickly find relevant sites.
 But, it's probably more important in terms of SEO: the more links you have,
 the higher your page's rank will be in search engines.
 And if you can get a link to your site on a popular site, all the better.
\end_layout

\begin_layout Standard
Because linkbacks require trust and mutuality, there are especially popular
 in the blogosphere, where bloggers often work with each other (sometimes
 antagonistically!) to create more hits, and thus generate more revenue.
\end_layout

\begin_layout Standard
Unfortunately, there's no single standard for linbacking, and all of them
 are rather cumbersome.
 Luckily, Diligence does most of the work for you: it features clients and
 servers for both the 
\begin_inset CommandInset href
LatexCommand href
name "Trackback"
target "http://www.sixapart.com/pronet/docs/trackback_spec"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "Pingback"
target "http://www.hixie.ch/specs/pingback/pingback"

\end_inset

 specs.
 As a server, it lets you accept these linkbacks from other sites, respond
 properly to the remote clients, and register the linkback in a MongoDB
 collection.
 As a client, it lets you auto-discover trackback and pingback URLs on remote
 pages, and do the necessary handshaking.
\end_layout

\begin_layout Standard
Pingback is by far the more complicated spec: it requires XML-RPC (we are
 using Diligence's RPC service for it), and also suggests that you make
 sure that the other site is indeed linking to you before registering.
 Trackback is more lightweight, but allows telling the target site more
 information about how you are linking them.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Linkback"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Linkback"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Integrating Linkbacks into Your Product
\end_layout

\begin_layout Standard
Diligence does a lot for you, but the burden is still on your to understand
 these non-trivial technologies well enough to integrate them properly into
 your application.
 On this page, we're featuring a rather elaborate example of how linkbacks
 work on this page for the purpose of demonstration.
 Much of this can be automated for your application: for example, in a blogging
 application, you might want to go over every new blog post and try out
 all the links on the page with Diligence.Linkback.discover to see if they
 support linkbacks, and then to do the linkback automatically without any
 user interaction.
 Or, you might prefer to have users explicitly click on a 
\begin_inset Quotes eld
\end_inset

linkback
\begin_inset Quotes erd
\end_inset

 feature.
 Diligence gives you the tools, making it as easy as possible for you to
 do the rest.
\end_layout

\begin_layout Subsubsection
How to Linkback 
\emph on
from
\emph default
 This Page?
\end_layout

\begin_layout Paragraph
1.
 Link
\end_layout

\begin_layout Standard
First, we need to make sure that we actually have a link to the remote site
 on our page.
 Here's a really simple form that lets you add links to this page:
\end_layout

\begin_layout Standard
<form id="add" method="POST"> <p> <%= Diligence.HTML.input({name: 'addPageUri',
 size: 70}, {_content: 'Page URL:'}) %> </p>
\end_layout

\begin_layout Standard
<p> <%= Diligence.HTML.submit({value: 'Add Link'}) %> </p>
\end_layout

\begin_layout Standard
</form> <form id="clear" method="POST"> <input type="hidden" name="clearPageUris
" value="true" /> <p>
\end_layout

\begin_layout Standard
<%= Diligence.HTML.submit({value: 'Clear Link List'}) %> </p> </form>
\end_layout

\begin_layout Standard
<p> Currently linked pages: <% for (var i = links.iterator(); i.hasNext();
 ) { var link = i.next(); %> <a href="<%= link %>">link</a> <% } %> </p>
\end_layout

\begin_layout Paragraph
2.
 Auto-Discovery
\end_layout

\begin_layout Standard
We support auto-discovery of trackback and pingback URLs, so you can first
 try to just enter the linked URL.
 Make sure it's one of the links you've added above! Pingback will be preferred
 if both Trackback and Pingback are supported by page.
\end_layout

\begin_layout Standard
<form id="linkback" method="POST"> <p> <%= Diligence.HTML.input({name: 'pageUri',
 size: 70}, {_content: 'Page URL:'}) %> </p> <h3>3.
 Or Use Explicit Linkback URLs</h3> <p> In case that doesn't work, you might
 also have to enter an explicit trackback or pingback URL posted on that
 page: </p>
\end_layout

\begin_layout Standard
<p> <%= Diligence.HTML.input({name: 'trackbackUri', size: 70}, {_content:
 'Trackback URL:'}) %> </p> <p> (Note that you do <i>not</i> need to enter
 the page URL with trackback, but you <i>do</i> need it it with pingback)
 </p> <p> <%= Diligence.HTML.input({name: 'pingbackUri', size: 70}, {_content:
 'Pingback URL:'}) %> </p>
\end_layout

\begin_layout Standard
<p> <%= Diligence.HTML.submit({value: 'Linkback'}) %> </p> </form> <% if (message)
 { %>
\end_layout

\begin_layout Standard
<p> <span style="color: red;"><%= message %></span> </p> <% } %>
\end_layout

\begin_layout Subsubsection
How to Linkback 
\emph on
to
\emph default
 This Page?
\end_layout

\begin_layout Standard
This page contains information about its trackback and pingback URLs.
 In case your software doesn't support auto-discovery of these, and you
 need to enter them explicitly, they are:
\end_layout

\begin_layout Standard
<p> <%= Diligence.HTML.input({value: Diligence.Linkback.getTrackbackUri(conversation.
reference), readonly: 'readonly', size: 70}, {_content: 'Trackback URL:'})
 %> </p> <p> <%= Diligence.HTML.input({value: Diligence.Linkback.getPingbackUri(),
 readonly: 'readonly', size: 70}, {_content: 'Pingback URL:'}) %> </p> 
\end_layout

\begin_layout Section
Nonces Service
\end_layout

\begin_layout Standard
This is a straightforward implementation of number-used-once, or 
\begin_inset Quotes eld
\end_inset

nonce,
\begin_inset Quotes erd
\end_inset

 using MongoDB atomic operations.
\end_layout

\begin_layout Standard
It allows you to issue a unique number, which you can then 
\begin_inset Quotes eld
\end_inset

check.
\begin_inset Quotes erd
\end_inset

 The check will work once 
\emph on
and only once 
\emph default
for any issued nonce, across all nodes accessing the same MongoDB database.
 Furthermore, every issued nonce is given an expiration time, after which
 it will be considered invalid.
\end_layout

\begin_layout Standard
Nonces are often used in authentication schemes, where tokens, meant to
 be used only once, are purposely issued for short time periods in order
 to minimize security risks.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Nonces"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Nonces"

\end_inset

.
\end_layout

\begin_layout Standard
The API is very simple.
 To issue a 60-second nonce:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/nonces/')
\end_layout

\begin_layout Plain Layout

var nonce = Diligence.Nonces.create(60 * 1000)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To check a nonce:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (!Diligence.Nonces.check(nonce)) {
\end_layout

\begin_layout Plain Layout

	print('Your token is invalid! Perhaps it was expired? Try logging in again.')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the nonces used in the API are 
\emph on
strings
\emph default
, which are hexadecimal representations of big integers.
 Strings are preferable in this use case, because you can be certain that
 precision will not be lost across various conversions and serializations.
 If you really need a non-hexadecimal representation, you can convert it
 a nonce using the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var nonceInteger = new java.math.BigInteger(nonce, 16)
\end_layout

\begin_layout Plain Layout

print(nonceInteger) // this will print a decimal representation of the nonce
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
The service removes expired nonces only when you check them.
 If it's important for you to save space and remove 
\emph on
all
\emph default
 expired nonces, you might want to call the Diligence.Nonces.prune method
 regularly.
 You can do this in your 
\begin_inset Quotes eld
\end_inset

crontab
\begin_inset Quotes erd
\end_inset

 file.
 Here's an example of doing so every 15 minutes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

*/15 * * * * <% document.executeOnce('/savory/service/nonces/'); Diligence.Nonces.p
rune(); %>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Notification Service
\end_layout

\begin_layout Standard
Sending out email from your application can quickly become difficult to
 manage when you have hundreds of thousands of emails to send out.
 But Diligence's Notification Service is here to help! Some key features:
\end_layout

\begin_layout Itemize
The implementation is optimized for high concurrency, making good use of
 MongoDB's atomic update features.
 This means that it's easy to scale: you can have many nodes all sending
 queued notices at the same time.
 They won't interfere with each other and there's no fear of having the
 same email sent more than once.
\end_layout

\begin_layout Itemize
It supports subscription channels: you can send a notice to the channel,
 and it would then be sent to all subscribers.
 This greatly minimizes the load on MongoDB.
 Moreover, you can use a notice template such that each subscriber gets
 a personalized email.
 Of course, you can also send direct notices to a single addressee.
\end_layout

\begin_layout Itemize
Automatic handling of daily and weekly digests for subscribers who prefer
 not to get individual emails.
 This works by merging notices into a digest document at scheduled times.
\end_layout

\begin_layout Itemize
You don't have to use email: the service implementation is pluggable, allowing
 you support other kinds of mailboxes if they make sense.
 For example, you might want to have an internal messaging feature for your
 application.
 The implementation is configured per subscriber, so you can support different
 kinds of mailboxes quite transparently.
\end_layout

\begin_layout Itemize
Supports both plain text and mixed-media HTML email.
\end_layout

\begin_layout Standard
Note that Diligence connects to but is 
\emph on
not
\emph default
 itself an SMTP server.
 SMTP servers are complex beasts in their own right: they must handle errors
 and retries, queuing of outgoing messages, as well as incoming ones if
 they are configured for relaying or for mailboxes.
 It's a good idea to keep that separate from your main application.
 We like 
\begin_inset CommandInset href
LatexCommand href
name "Postfix"
target "http://www.postfix.org/"

\end_inset

, a mature SMTP server that offers excellent scalability and security.
\end_layout

\begin_layout Standard
If you want your application to 
\emph on
receive
\emph default
 email, which is quite a different task than relaying it onwards, we recommend
 the 
\begin_inset CommandInset href
LatexCommand href
name "SubEtha SMTP library"
target "http://code.google.com/p/subethasmtp/"

\end_inset

.
 If there's interest, we may incorporate into Diligence more directly in
 the future.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Notification"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Notification"

\end_inset

.
\end_layout

\begin_layout Standard
Here's an example of two ways for queuing a notice, the first by a direct
 address, and the second to all subscribers of a channel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/notification/') 
\end_layout

\begin_layout Plain Layout

Diligence.Notification.queueForAddress('Email', 'email@myorg.org', {subject:
 'The Subject', text: 'The content.})
\end_layout

\begin_layout Plain Layout

Diligence.Notification.queueForChannel('main', {subject: 'The Subject', text:
 'The content.'}) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first option doesn't require any subscription: it uses 
\begin_inset Quotes eld
\end_inset

Email
\begin_inset Quotes erd
\end_inset

 as the implementation (see 
\begin_inset Quotes eld
\end_inset

configuration,
\begin_inset Quotes erd
\end_inset

 below), with the second argument being an identifier for that implementation
 (in this case, simply an email address).
 The second option queues the notice on the channel named 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset

.
 To add a subscription, you can do the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Diligence.Notification.subscribe('main', {service: 'Email', address: 'email@myorg.o
rg', mode: 'daily'})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 key can be 
\begin_inset Quotes eld
\end_inset

immediate
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

daily
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

weekly
\begin_inset Quotes erd
\end_inset

, with the latter two modes for digests.
 You don't need to create the channel itself: adding at least one subscription
 will automatically do that.
\end_layout

\begin_layout Standard
In the above examples we've sent plain text emails.
 To add HTML, add an 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

 key.
 Note that if you use 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

 you need to 
\emph on
also
\emph default
 add 
\begin_inset Quotes eld
\end_inset

text
\begin_inset Quotes erd
\end_inset

 to specify the plain text version.
 This is very good practice: not all email clients support HTML, and if
 they don't your HTML will be unreadable without a plain text fallback.
\end_layout

\begin_layout Standard
It might be useful to make use of the Sincerity.Mail.MessageTemplate class,
 which lets you store messages in text packs.
 For more information on text packs, see the Internationalization Service.
\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
In your application's 
\begin_inset Quotes eld
\end_inset

settings.js
\begin_inset Quotes erd
\end_inset

 you want to make sure to enable lazy configuration:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/prudence/lazy/')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And then add something like this to your app.globals:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.globals = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	savory: {
\end_layout

\begin_layout Plain Layout

		service: {
\end_layout

\begin_layout Plain Layout

			notification: {
\end_layout

\begin_layout Plain Layout

				services: {
\end_layout

\begin_layout Plain Layout

					'.': Prudence.Lazy.build({
\end_layout

\begin_layout Plain Layout

						Email: {
\end_layout

\begin_layout Plain Layout

							dependencies: '/savory/service/notification/service/email/',
\end_layout

\begin_layout Plain Layout

							name: 'Diligence.Notification.EmailService',
\end_layout

\begin_layout Plain Layout

							config: {
\end_layout

\begin_layout Plain Layout

								from: 'myaddress@mymail.org',
\end_layout

\begin_layout Plain Layout

								site: 'Diligence Example'
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

					})
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the use of Prudence.Lazy.build: this allows the Notification Service
 to lazily create the email implementation on demand during runtime.
 The key, 
\begin_inset Quotes eld
\end_inset

Email
\begin_inset Quotes erd
\end_inset

, will be used in subscriptions, as in the examples above.
 Note that it is case-sensitive.
 Within the lazy configuration, the 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 key is the class to instantiate, the 
\begin_inset Quotes eld
\end_inset

config
\begin_inset Quotes erd
\end_inset

 is sent to the class constructor, and values in the 
\begin_inset Quotes eld
\end_inset

dependencies
\begin_inset Quotes erd
\end_inset

 key are used for 
\begin_inset Quotes eld
\end_inset

document.executeOnce
\begin_inset Quotes erd
\end_inset

.
 Also note the use of the 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 key to avoid flattening of the resulting lazy build (see Sincerity.Objects.flatte
n).
\end_layout

\begin_layout Standard
If you want to write your own service implementations, see the source code
 for the Diligence.Notification.EmailService.
\end_layout

\begin_layout Standard
To set up the background tasks for sending out queued notices, add something
 like the following to your application's 
\begin_inset Quotes eld
\end_inset

crontab
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

* * * * * <% document.executeOnce('/savory/service/notification/'); Diligence.Noti
fication.sendQueuedNotices(); %>
\end_layout

\begin_layout Plain Layout

* 4 * * * <% document.executeOnce('/savory/service/notification/'); Diligence.Noti
fication.sendQueuedDigests('daily'); %>
\end_layout

\begin_layout Plain Layout

* 5 * * 0 <% document.executeOnce('/savory/service/notification/'); Diligence.Noti
fication.sendQueuedDigests('weekly'); %> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above will check for and send regular notices every minute, send daily
 digests at 4am, and send weekly digests every Sunday at 5am.
 As stated above, you can have this same 
\begin_inset Quotes eld
\end_inset

crontab
\begin_inset Quotes erd
\end_inset

 running on many nodes.
 Because the implementation relies on MongoDB's atomic updates, you can
 be sure that notices will not be sent more than once.
\end_layout

\begin_layout Section
Progress Service
\end_layout

\begin_layout Standard
If you've read Prudence's 
\begin_inset CommandInset href
LatexCommand href
name "Scaling Tips"
target "http://threecrickets.com/prudence/scaling/"

\end_inset

 article, you know that for potentially long-running tasks you want to release
 web request threads as soon as possible, and notify the user in some way
 as to when the task is finished.
 This service helps you do exactly that.
\end_layout

\begin_layout Standard
For a use case example, consider an application that searches for flight
 information using several databases and services.
 The search can take many seconds, if not minutes! Of course, you do not
 want to hold up a web request thread and have the browser spin while the
 search is going on, so you turn to Diligence's Progress Service.
\end_layout

\begin_layout Standard
It works like this: you create a 
\begin_inset Quotes eld
\end_inset

process,
\begin_inset Quotes erd
\end_inset

 which is stored in a MongoDB document, and you can asynchronously mark
 when certain 
\begin_inset Quotes eld
\end_inset

milestones
\begin_inset Quotes erd
\end_inset

 are completed, including the final completion of the whole process.
 Processes can be associated with a user, which allows you to use the <a
 href="../authorization/">authorization service</a> to allow only that user
 access to the process' status, and also to allow the user to query all
 processes associated with them.
\end_layout

\begin_layout Standard
The service supports two ways of letting the user know the status of the
 process.
 The first is for short-term processes: a drop-in fragment that simply shows
 the current status of the process and uses browser JavaScript to refresh
 the page every few seconds.
 The user would see milestones along the way to completion, if there are
 any, and eventually be redirected to another page when the process completes
 (or fails!).
\end_layout

\begin_layout Standard
For longer running processes, you cannot expect the user to wait in front
 of the web browsers.
 In these cases, the Progress Service uses the <a href="../notification/">notifica
tion service</a> to notify the user about milestones, success and failure.
 Additionally, we provide a drop-in fragment that would allow the user to
 see the current state of the process on the web, and another one that lets
 the user access all processes associated with them.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Progress"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Progress"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Trivial Example
\end_layout

\begin_layout Standard
This fake process will simply do nothing until its expiration:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/progress/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var process = Diligence.Progress.startProcess({
\end_layout

\begin_layout Plain Layout

	description: 'Searching for your flights...',
\end_layout

\begin_layout Plain Layout

	maxDuration: 20 * 1000,
\end_layout

\begin_layout Plain Layout

	redirect: conversation.reference
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

process.redirectWait(conversation, application)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That final redirectWait call will send the user to a 
\begin_inset Quotes eld
\end_inset

please wait
\begin_inset Quotes erd
\end_inset

 page which will show 
\begin_inset Quotes eld
\end_inset

Searching for your flights\SpecialChar \ldots{}

\begin_inset Quotes erd
\end_inset

 as the text, and have a progress bar.
 The page will automatically refresh and show ongoing progress.
 After 20 seconds of this, it will redirect back to this page.
 Note that you can specify different redirect URIs for success, error, timeouts,
 etc.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

please wait
\begin_inset Quotes erd
\end_inset

 page is in 
\begin_inset Quotes eld
\end_inset

/savory/service/progress/wait/
\begin_inset Quotes erd
\end_inset

.
 If you don't have it in your 
\begin_inset Quotes eld
\end_inset

/fragments/
\begin_inset Quotes erd
\end_inset

 then a default page will be used, which is in your container's 
\begin_inset Quotes eld
\end_inset

/libraries/prudence/
\begin_inset Quotes erd
\end_inset

 directory.
 You can use that as a template for your own custom page.
\end_layout

\begin_layout Subsubsection
Example with Milestones
\end_layout

\begin_layout Standard
You can launch a task from within startProcess, which in turns call the
 
\begin_inset CommandInset href
LatexCommand href
name "Prudence.Tasks API"
target "http://threecrickets.com/javascript-api/?namespace=Prudence.Tasks"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var searchString = 'flight #1234' 
\end_layout

\begin_layout Plain Layout

var process = Diligence.Progress.startProcess({
\end_layout

\begin_layout Plain Layout

	description: 'Searching for your flights...',
\end_layout

\begin_layout Plain Layout

	maxDuration: 60 * 1000,
\end_layout

\begin_layout Plain Layout

	redirect: '/flight/results/',
\end_layout

\begin_layout Plain Layout

	task: {
\end_layout

\begin_layout Plain Layout

		name: '/flight/search/',
\end_layout

\begin_layout Plain Layout

		searchString: searchString, // this is our custom field
\end_layout

\begin_layout Plain Layout

		distributed: true
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our 
\begin_inset Quotes eld
\end_inset

/libraries/flights/search.js
\begin_inset Quotes erd
\end_inset

 would look like this: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/processing/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var process = Diligence.Progress.getProcess()
\end_layout

\begin_layout Plain Layout

if (process && process.isActive()) {
\end_layout

\begin_layout Plain Layout

	var task = process.getTask()
\end_layout

\begin_layout Plain Layout

	var milestone = process.getLastMilestone()
\end_layout

\begin_layout Plain Layout

	switch (milestone.name) {
\end_layout

\begin_layout Plain Layout

		case 'started':
\end_layout

\begin_layout Plain Layout

			process.addMilestone({name: 'ours', description: 'Searching our flight
 database'})
\end_layout

\begin_layout Plain Layout

			var found = searchOurDatabase(task.searchString)
\end_layout

\begin_layout Plain Layout

			if (found) {
\end_layout

\begin_layout Plain Layout

				process.addMilestone({name: 'done'})
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				Prudence.Tasks.task(task)
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			break 
\end_layout

\begin_layout Plain Layout

		case 'ours':
\end_layout

\begin_layout Plain Layout

			process.addMilestone({name: 'partners', description: 'Searching our partner
 databases'}
\end_layout

\begin_layout Plain Layout

			var found = searchPartnerDatabases(task.searchString)
\end_layout

\begin_layout Plain Layout

			if (found) {
\end_layout

\begin_layout Plain Layout

				process.addMilestone({name: 'done'})
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				process.addMilestone({name: 'failed'})
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			break
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes:
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

Diligence.Progress.getProcess()
\begin_inset Quotes erd
\end_inset

 API works here only because we launched the task from within startProcess.
 (It works by putting the process ID in the task context.)
\end_layout

\begin_layout Itemize
The first milestone is always 
\begin_inset Quotes eld
\end_inset

started
\begin_inset Quotes erd
\end_inset

, and the last one is always 
\begin_inset Quotes eld
\end_inset

done
\begin_inset Quotes erd
\end_inset

.
 The name 
\begin_inset Quotes eld
\end_inset

failed
\begin_inset Quotes erd
\end_inset

 is reserved for failed processes, and like 
\begin_inset Quotes eld
\end_inset

done
\begin_inset Quotes erd
\end_inset

 will mark the process as inactive.
 Otherwise, you can set any milestone name you wish.
\end_layout

\begin_layout Itemize
You'll also see that we've handled each milestone as a new execution of
 the task.
 
\begin_inset Quotes eld
\end_inset

process.getTask()
\begin_inset Quotes erd
\end_inset

 returns a copy of the arguments sent to the last Prudence.Tasks.task call,
 so we can simply call it again with the same arguments.
\end_layout

\begin_layout Itemize
Breaking up our work into separate tasks allows for better concurrency:
 we're not holding on the thread at once longer than makes sense.
 Also note that if the task is distributed, each milestone could be executed
 in a different node in the cluster.
\end_layout

\begin_layout Itemize
This method and also makes sure that a milestone will not be executed if
 a process expires (isActive would return false).
\end_layout

\begin_layout Subsubsection
Reattempts
\end_layout

\begin_layout Standard
A common use case for the processing service is in dealing with an unreliable
 action that might actually succeed after a few attempts.
 You'd thus want to let the user wait until a certain maximum duration,
 and keep retrying every few seconds in the background until the action
 succeeds.
\end_layout

\begin_layout Standard
The Progress Service automates much of this using the 
\begin_inset Quotes eld
\end_inset

maxAttempts
\begin_inset Quotes erd
\end_inset

 key in 
\begin_inset Quotes eld
\end_inset

task
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var ipAddressOfRemoteLocation = '1.2.3.4'
\end_layout

\begin_layout Plain Layout

var process = Diligence.Progress.startProcess({
\end_layout

\begin_layout Plain Layout

	description: 'Attemping to connect you to remote location {0}...'.cast(ipAddressOfR
emoteLocation),
\end_layout

\begin_layout Plain Layout

	maxDuration: 5 * 60 * 1000,
\end_layout

\begin_layout Plain Layout

	redirect: '/remote/connected/',
\end_layout

\begin_layout Plain Layout

	task: {
\end_layout

\begin_layout Plain Layout

		name: '/remote/connect/',
\end_layout

\begin_layout Plain Layout

		maxAttempts: 10, // for reattempts
\end_layout

\begin_layout Plain Layout

		delay: 5000, // between reattempts
\end_layout

\begin_layout Plain Layout

		remoteLocation: ipAddressOfRemoteLocation // this is our custom field
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our 
\begin_inset Quotes eld
\end_inset

/libraries/remote/connect.js
\begin_inset Quotes erd
\end_inset

 would look something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/progress/')
\end_layout

\begin_layout Plain Layout

var process = Diligence.Progress.getProcess()
\end_layout

\begin_layout Plain Layout

if (process) {
\end_layout

\begin_layout Plain Layout

	process.attempt(function(process) {
\end_layout

\begin_layout Plain Layout

		document.executeOnce('/mylibrary/connections/')
\end_layout

\begin_layout Plain Layout

		return connectRemote(process.getTask().remoteLocation)
\end_layout

\begin_layout Plain Layout

	})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes:
\end_layout

\begin_layout Itemize
The process.attempt call doest most of the work: it makes sure to call the
 task again if there's still time before the process expires and the maximum
 number of attempts has not been exceeded, waiting the appropriate delay
 before each attempt.
 Your function just has to make sure to return true if the attempt has succeeded.
\end_layout

\begin_layout Itemize
Each attempt will get a milestone name in the form of 
\begin_inset Quotes eld
\end_inset

attempt #X
\begin_inset Quotes erd
\end_inset

 where X starts at 1.
\end_layout

\begin_layout Itemize
If the maximum number of attempts has been reached, the milestone will be
 set to 
\begin_inset Quotes eld
\end_inset

failed
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Reattempts are logged, to help you debug problems.
\end_layout

\begin_layout Section
REST Service
\end_layout

\begin_layout Standard
The REST Service makes it easy to create a RESTful API layer over your MongoDB
 database.
 It's powerful enough that it may be in itself the primary reason why you
 wish to use Diligence.
\end_layout

\begin_layout Standard
While there are tools to do this automatically---and the REST Service does
 have an automatic mode, too---the true power of this service is in its
 customizability.
 You can insert your own code anywhere in the resources to do special processing
, for anything from data validation, through constraint enforcement, to
 security authorization and high-level business logic.
\end_layout

\begin_layout Standard
Moreover, the Prudence platform lets you access this RESTful layer internally,
 without any HTTP communication or serialization, so that you can use this
 layer as your primary data access layer API, both internally and for other
 services.
 There's no reason to create a separate API for internal vs.
 external use.
 This architecture also makes it trivial to separate your data processing
 nodes from your application logic nodes, should you ever want to do so.
\end_layout

\begin_layout Standard
Even without customization via code, out of the box you get the following
 features:
\end_layout

\begin_layout Itemize
The default format immediately supports Ext JS's RESTful data stores.
 Attach any MongoDB collection to an editable grid widget in a web browser!
 See the Sencha Integration manual for more information.
\end_layout

\begin_layout Itemize
Automatic content negotiation with support for JSON and XML formats, as
 well as a human-readable HTML format perfect for debugging via browsers.
 The HTML format even allows simple editing of your content.
 (Note, though, that if you want a full-fledged web frontend for your MongoDB
 data, you're better off with 
\begin_inset CommandInset href
LatexCommand href
name "MongoVision"
target "http://code.google.com/p/mongo-vision/"

\end_inset

, which is easily installable side-by-side with your Diligence application.)
\end_layout

\begin_layout Itemize
Pagination for traversing collections of any size.
\end_layout

\begin_layout Itemize
Choose which document fields you want to expose, and extract sub-documents
 from your main document.
\end_layout

\begin_layout Itemize
Apply straightforward 
\begin_inset Quotes eld
\end_inset

modes,
\begin_inset Quotes erd
\end_inset

 which let you transform MongoDB's extended JSON format into simpler primitives.
 For example, 
\begin_inset Quotes eld
\end_inset

{$date: 1234}
\begin_inset Quotes erd
\end_inset

 would become 
\begin_inset Quotes eld
\end_inset

1234
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
There are a lot of details below, but you shouldn't be intimidated by them.
 You do not have to learn every single feature of the REST Service in order
 to use it.
 In just a few lines of code, you can setup a whole RESTful layer automatically
 that will 
\begin_inset Quotes eld
\end_inset

just work
\begin_inset Quotes erd
\end_inset

 for many use cases.
\end_layout

\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.REST"
target "http://threecrickets.com/javascript-api/?namespace=Savory.REST"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Manual Setup
\end_layout

\begin_layout Standard
We'll start with manual configuration, because it will help you better understan
d how the REST Service works.
\end_layout

\begin_layout Standard
First, let's configure the URI-space in your application's 
\begin_inset Quotes eld
\end_inset

routing.js
\begin_inset Quotes erd
\end_inset

.
 Add the following to app.routes and app.dispatchers:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/data/users/{id}/': {type: 'implicit', id: 'users'},
\end_layout

\begin_layout Plain Layout

	'/data/users/':      {type: 'implicit', id: 'users.plural'}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.dispatchers = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	javascript: {library: '/resources/'}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now configure our resources in 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/rest/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	users:          new Diligence.REST.MongoDbResource({name: 'users'}),
\end_layout

\begin_layout Plain Layout

	'users.plural': new Diligence.REST.MongoDbResource({name: 'users', plural:
 true})
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Automatic Setup
\end_layout

\begin_layout Standard
The REST Service can do all the above automatically for you, which is especially
 useful if you have lots of collections, or if you keep adding collections
 and want resources for them to be added automatically.
 Note that this automation does not occur dynamically while your application
 is running: you have to restart for this to work.
\end_layout

\begin_layout Standard
In your application's 
\begin_inset Quotes eld
\end_inset

routing.js
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MongoDB = null
\end_layout

\begin_layout Plain Layout

document.execute('/mongo-db/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/rest/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Sincerity.Objects.merge(app.routes, Diligence.REST.createMongoDbRoutes({prefix:
 '/data/'}))
\end_layout

\end_inset


\end_layout

\begin_layout Quote
Important! The first two lines of code make sure that MongoDB is re-initialized
 before proceeding, so that we can be sure to avoid using the default MongoDB
 initialization in other applications.
 This is good practice when using Diligence in any initialization script.
\end_layout

\begin_layout Standard
In 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

, we just need this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/rest/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Sincerity.Objects.merge(resources, Diligence.REST.createMongoDbResources())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also specify exactly which collections you want created:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Diligence.REST.createMongoDbResources({collections: ['users','notices','documents'
]})
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Custom Queries
\end_layout

\begin_layout Standard
Sometimes you may be using a single MongoDB collection as a container for
 documents of several different types, and you would want them exposed as
 a separate URI-space.
\end_layout

\begin_layout Standard
The REST Service allows for this via a simple querying language.
 To illustrate it, lets first look at what the default query is for singular
 resources, if no query is provided by you:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	users: new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

		name: 'users',
\end_layout

\begin_layout Plain Layout

		query: {_id: {$oid: '{id}'}}
\end_layout

\begin_layout Plain Layout

	})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/data/users/{id}/': {type: 'implicit', id: 'users'}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

query
\begin_inset Quotes erd
\end_inset

 key is in MongoDB's extended JSON format, and is used for the MongoDB 
\begin_inset Quotes eld
\end_inset

find
\begin_inset Quotes erd
\end_inset

 operation.
 The values are all cast using the conversation.locals, which, if you remember
 how to do Prudence routing, are extracted from the URI template.
 Let's look at this slowly:
\end_layout

\begin_layout Enumerate
If a 
\begin_inset Quotes eld
\end_inset

/data/users/123/
\begin_inset Quotes erd
\end_inset

 URI is accessed with a GET operation, the 
\begin_inset Quotes eld
\end_inset

123
\begin_inset Quotes erd
\end_inset

 will be extracted from the URI template.
 The effect will be as if we called:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

conversation.locals.put('id', '123')
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
All the values in our resource's 
\begin_inset Quotes eld
\end_inset

query
\begin_inset Quotes erd
\end_inset

 value are cast using conversation.locals.
 So, our final query will be:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{_id: {$oid: '123'}}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
The REST Service will use the above query for a 
\begin_inset Quotes eld
\end_inset

find
\begin_inset Quotes erd
\end_inset

 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var data = collection.findOne({_id: {$oid: '123'}})
\end_layout

\end_inset

(Note that the 
\begin_inset Quotes eld
\end_inset

$oid
\begin_inset Quotes erd
\end_inset

 in MongoDB's extended JSON becomes an ObjectId in BSON.)
\end_layout

\begin_layout Standard
Knowing this, you can then set the 
\begin_inset Quotes eld
\end_inset

query
\begin_inset Quotes erd
\end_inset

 any way you like.
 You can use values extracted from conversation.locals, or any literal value.
 For example, let's create a URI-space for users of type 
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

, to be accessed :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	admins: new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

		name: 'users',
\end_layout

\begin_layout Plain Layout

		query: {name: '{name}'}, {type: 'admin'}}
\end_layout

\begin_layout Plain Layout

	}),
\end_layout

\begin_layout Plain Layout

	'admins.plural': new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

		name: 'users',
\end_layout

\begin_layout Plain Layout

		query: {type: 'admin'},
\end_layout

\begin_layout Plain Layout

		plural: true
\end_layout

\begin_layout Plain Layout

	})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/data/admins/{name}/': {type: 'implicit', id: 'admins'},
\end_layout

\begin_layout Plain Layout

	'/data/admins/':        {type: 'implicit', id: 'admins.plural'}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a convenience, you can also add custom values to be cast using the 
\begin_inset Quotes eld
\end_inset

values
\begin_inset Quotes erd
\end_inset

 key.
 These will be merged with values from conversation.locals:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

	name: 'users',
\end_layout

\begin_layout Plain Layout

	query: {name: '{name}'}, {type: '{type}'}},
\end_layout

\begin_layout Plain Layout

	values: {type: 'admin'}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This allows for nice reusability when you create your own extended classes:
 you can share one query among many subclasses.
\end_layout

\begin_layout Subsubsection
Custom Extraction
\end_layout

\begin_layout Standard
By default, the REST Service will extract and return the entire MongoDB
 document, but you can customize this quite powerfully, even to allow you
 to access sub-documents inside a document.
\end_layout

\begin_layout Standard
First off, you can simply choose the fields you want:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

	name: 'users',
\end_layout

\begin_layout Plain Layout

	fields: ['name', 'email', 'address']
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

fields
\begin_inset Quotes erd
\end_inset

 key will be used at the level of MongoDB's driver, so that unused data
 won't even be retrieved from the database.
\end_layout

\begin_layout Standard
You can go further and extract sub-fields:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'users.email': new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

		name: 'users',
\end_layout

\begin_layout Plain Layout

		fields: 'email',
\end_layout

\begin_layout Plain Layout

		extract: 'email'
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/data/users/{id}/email': {type: 'implicit', id: 'users.email'},
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result of a GET would be only a string of the email address.
 An example in JSON:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

"myemail@mail.org"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Without the 
\begin_inset Quotes eld
\end_inset

extract
\begin_inset Quotes erd
\end_inset

, the representation would be this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"_id": {
\end_layout

\begin_layout Plain Layout

		"$oid": "4e057e94e799a23b0f581d7d"
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"email": "myemail@mail.org"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Quote
Important! Not all client JSON parsers can deal with JSON data that is not
 a dict or an array.
 If you are extracting data that is not a dict or an array, you may need
 to implement your own special parsing.
\end_layout

\begin_layout Standard
With 
\begin_inset Quotes eld
\end_inset

extract
\begin_inset Quotes erd
\end_inset

 you can go further and even provide an array that will be extracted in
 order.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'users.groups': new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

		name: 'users',
\end_layout

\begin_layout Plain Layout

		fields: 'authorization',
\end_layout

\begin_layout Plain Layout

		extract: ['authorization', 'entities']
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/data/users/{id}/groups': {type: 'implicit', id: 'users.groups'},
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above actually uses the data structure used by Diligence's Authorization
 Service to retrieve the security groups.
 The result of a GET would be an array.
 An example in JSON:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

["users", "admins"]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, you can do your own custom extraction, by providing a function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

	name: 'users',
\end_layout

\begin_layout Plain Layout

	fields: 'authorization',
\end_layout

\begin_layout Plain Layout

	extract: function(doc) {
\end_layout

\begin_layout Plain Layout

		return doc.authorization.entities.join(',')
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Custom Modes
\end_layout

\begin_layout Standard
You can set up your own custom modes like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

new Diligence.REST.MongoDbResource({
\end_layout

\begin_layout Plain Layout

	name: 'users',
\end_layout

\begin_layout Plain Layout

	modes: {
\end_layout

\begin_layout Plain Layout

		flat: function(data) {
\end_layout

\begin_layout Plain Layout

			return Sincerity.Objects.flatten(data)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See 
\begin_inset Quotes eld
\end_inset

Usage
\begin_inset Quotes erd
\end_inset

 below for information on how to use modes.
\end_layout

\begin_layout Subsubsection
Overriding
\end_layout

\begin_layout Standard
There are two ways to override the default behavior: 1) inherit the Diligence.Mon
goDbResource class using the 
\begin_inset CommandInset href
LatexCommand href
name "Sincerity.Classes API"
target "http://threecrickets.com/javascript-api/?namespace=Sincerity.Classes"

\end_inset

, or 2) monkey-patch the instances.
 The former method is more reusable, but the latter method works just as
 well and is easier if you just need to customize a single resource.
 Example of monkey-patching:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	users: new Diligence.REST.MongoDbResource({name: 'users'})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources.users.doDelete = function(conversation) {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	// Call overridden method
\end_layout

\begin_layout Plain Layout

	arguments.callee.overridden.call(this, conversation)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using this method you can even monkey-patch instances created automatically
 after a call to 
\begin_inset Quotes eld
\end_inset

Diligence.REST.createMongoDbResources()
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
In-Memory Data
\end_layout

\begin_layout Standard
The REST Service does not have to use MongoDB to store data: it also supports
 storing data in memory, even shared memory distributed in the Prudence
 cluster.
\end_layout

\begin_layout Standard
This is useful if you don't need persistent storage in MongoDB (the data
 is considered volatile) and is also useful for creating mock data for testing.
 The URI-space otherwise behaves exactly the same as if it were attached
 to MongoDB collections.
 Performance, of course, should be better than if you were accessing MongoDB.
 On the other, your storage size is limited to your RAM.
 So, while this feature is not a replacement for using MongoDB, it can be
 quite useful in various scenarios.
\end_layout

\begin_layout Standard
Let's modify our example from above to use in-memory resources:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/sincerity/jvm/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var users = {
\end_layout

\begin_layout Plain Layout

	'4e057e94e799a23b0f581d7d': {
\end_layout

\begin_layout Plain Layout

		_id: '4e057e94e799a23b0f581d7d',
\end_layout

\begin_layout Plain Layout

		name: 'newton',
\end_layout

\begin_layout Plain Layout

		lastSeen: new Date()
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	'4e057e94e799a23b0f581d7e': {
\end_layout

\begin_layout Plain Layout

		_id: '4e057e94e799a23b0f581d7e',
\end_layout

\begin_layout Plain Layout

		name: 'sagan',
\end_layout

\begin_layout Plain Layout

		lastSeen: new Date()
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var usersMap = Sincerity.JVM.toMap(users, true)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	users:          new Diligence.REST.InMemoryResource({name: 'users', documents:
 usersMap}),
\end_layout

\begin_layout Plain Layout

	'users.plural': new Diligence.REST.InMemoryResource({name: 'users', documents:
 usersMap, plural: true})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that we translated the 
\begin_inset Quotes eld
\end_inset

users
\begin_inset Quotes erd
\end_inset

 dict into a thread-safe JVM map.
 We could have also just sent the 
\begin_inset Quotes eld
\end_inset

users
\begin_inset Quotes erd
\end_inset

 dict directly to the 
\begin_inset Quotes eld
\end_inset

InMemoryResource
\begin_inset Quotes erd
\end_inset

 constructor, which can create the map for us.
 But, since we have 
\emph on
two
\emph default
 resources, the singular and the plural, and we want them to share the same
 map, we have created this map ourselves.
\end_layout

\begin_layout Standard
What if you're in a Prudence cluster, and want all nodes to share the same
 in-memory data? Let's modify our code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	users:          new Diligence.REST.DistributedResource({name: 'users', documents:
 users}),
\end_layout

\begin_layout Plain Layout

	'users.plural': new Diligence.REST.DistributedResource({name: 'users', documents:
 users, plural: true})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code is even simpler than the 
\begin_inset Quotes eld
\end_inset

InMemoryResource
\begin_inset Quotes erd
\end_inset

 code (no need to create 
\begin_inset Quotes eld
\end_inset

usersMap
\begin_inset Quotes erd
\end_inset

), but requires some explanation:
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 field will be used as the name of the Hazelcast map.
 You can configure this map by name in the Hazelcast configuration, otherwise
 it will use the Hazelcast defaults for new maps.
\end_layout

\begin_layout Itemize
The data from the 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 field will be copied into the Hazelcast 
\emph on
only once
\emph default
 and 
\emph on
only if the map is already empty
\emph default
.
 Thus, it should be thought of as your initialization data: the first time
 a resource is set up for that map, from anywhere in the cluster, this data
 will be copied in.
 From then on, for the life of the cluster, 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 will be ignored.
 Thus, if you want to re-initialize the map, you will need to either restart
 your whole cluster, or programmatically set the data.
 (The Diligence Console would be very useful for that.)
\end_layout

\begin_layout Itemize
Note that we are serializing data using JSON into the distributed map.
 The performance hit should be minimal, but it's important to remember that
 only your data must be extended-JSON-compatible.
 (The 
\begin_inset Quotes eld
\end_inset

InMemoryResource
\begin_inset Quotes erd
\end_inset

 doesn't have this restriction.)
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Subsubsection
Resource Characteristics
\end_layout

\begin_layout Standard
All resources support the following URI query parameters:
\end_layout

\begin_layout Itemize

\series bold
format
\series default
: You can use this to specify the exact format you want, overriding any
 HTTP content negotiation.
 This is useful for testing and debugging, but can also help you in dealing
 with HTTP clients that can't easily set headers.
 Accepted values are 
\begin_inset Quotes eld
\end_inset

json
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

html
\begin_inset Quotes erd
\end_inset

.
 Note that when accessing resources internally, no serialization happens,
 and 
\begin_inset Quotes eld
\end_inset

format
\begin_inset Quotes erd
\end_inset

 is unnecessary.
\end_layout

\begin_layout Itemize

\series bold
human
\series default
: Setting this to 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 will further help your debugging, as it will return nicely indented, multiline
 JSON or XML representations.
\end_layout

\begin_layout Itemize

\series bold
mode:
\series default
 
\begin_inset Quotes eld
\end_inset

Modes
\begin_inset Quotes erd
\end_inset

 are simple functions that are applied to all documents in order to transform
 the final representation.
 The REST Service comes with a few useful modes, but you can easily create
 your own, just make sure to hook them to the instance using the 
\begin_inset Quotes eld
\end_inset

modes
\begin_inset Quotes erd
\end_inset

 key.
 The query parameter value will be mapped to a key in this dict.
 Note that you can provide multiple 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 values, in which case all mode functions will be called in order.
 Provided modes:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
primitive:
\series default
 This converts MongoDB extended values into simpler JSON structures.
 For example, 
\begin_inset Quotes eld
\end_inset

{timestamp: {$date: 12345}}
\begin_inset Quotes erd
\end_inset

 will become 
\begin_inset Quotes eld
\end_inset

{timestamp: 12345}
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
string
\series default
: This converts all JSON values into strings.
 It's a good way to overcome various number accuracy issues, especially
 when dealing with PHP clients.
\end_layout

\begin_layout Itemize

\series bold
stringid:
\series default
 Converts only the 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 field to a string, in case it's a BSON ObjectId.
 Some clients, such as Ext JS, cannot deal with ID values that are dicts.
\end_layout

\end_deeper
\begin_layout Standard
An example URI with all the above parameters:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/data/users/4e057e94e799a23b0f581d7d/?format=json&human=true&mode=primitive&mode
=string
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As for payloads, in POST and PUT operations, note that by default they must
 be in JSON, even if you are representing the result in XML or HTML.
 The reason is that there is no obvious way to translate XML to the final
 JSON format needed by MongoDB.
 If you do need to support XML payloads, you can override 
\begin_inset Quotes eld
\end_inset

handlePost
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

handlePut
\begin_inset Quotes erd
\end_inset

 to do this yourself according to your specifications.
\end_layout

\begin_layout Subsubsection
Singular Resources
\end_layout

\begin_layout Standard
The REST Service will by default extract the 
\begin_inset Quotes eld
\end_inset

{id}
\begin_inset Quotes erd
\end_inset

 pattern in the URI into a MongoDB ObjectID for the document 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 field.
 For example, if your route is 
\begin_inset Quotes eld
\end_inset

/data/users/{id}/
\begin_inset Quotes erd
\end_inset

, then 
\begin_inset Quotes eld
\end_inset

/data/users/4e057e94e799a23b0f581d7d/
\begin_inset Quotes erd
\end_inset

 would refer to the user document with that 
\begin_inset Quotes eld
\end_inset

_id.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Requests to the URI always return 404 if the document does not exist.
 Further notes:
\end_layout

\begin_layout Itemize

\series bold
POST:
\series default
 All keys of the payload will be used for a 
\begin_inset Quotes eld
\end_inset

$set
\begin_inset Quotes erd
\end_inset

 in a MongoDB 
\begin_inset Quotes eld
\end_inset

findAndModify
\begin_inset Quotes erd
\end_inset

 operation, and the modified document will be returned.
 If you include an 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 key in the payload it will be removed, because the ID in the URI takes
 precedence.
\end_layout

\begin_layout Itemize

\series bold
PUT:
\series default
 The payload will become a simple MongoDB 
\begin_inset Quotes eld
\end_inset

save
\begin_inset Quotes erd
\end_inset

 operation, which is an upsert, meaning it would either create a new resource
 or replace the existing one.
 If you include an 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 key in the payload it will be removed, because the ID in the URI takes
 precedence.
 Note that if you want to create a new resource, it's up to you to make
 sure the the id is unique, otherwise you will get an HTTP 409 error (conflict).
 You can generate a unique ID by calling MongoDB.newId().
 Example for generating a unique URI using templates:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'/data/users/{0}/'.cast(MongoDB.newId())
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Plural Resources
\end_layout

\begin_layout Standard
The plural resource is a bit more complex.
 The returned representations include a 
\begin_inset Quotes eld
\end_inset

total
\begin_inset Quotes erd
\end_inset

 key, counting the size of the collection, and a 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 key, containing an array of specific documents.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"total": 1092,
\end_layout

\begin_layout Plain Layout

	"documents": [
\end_layout

\begin_layout Plain Layout

		{"_id": {"$oid": "4e057f2ae799a23b0f581d7f" }, ...
 }
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following additional query parameters are supported for pagination,
 controlling which documents are included in the 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 array:
\end_layout

\begin_layout Itemize

\series bold
start:
\series default
 The index from which to start collecting documents.
 By default it will be 0.
\end_layout

\begin_layout Itemize

\series bold
limit:
\series default
 The maximum number of documents to return.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 array can definitely be empty if your 
\begin_inset Quotes eld
\end_inset

start
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

limit
\begin_inset Quotes erd
\end_inset

 values are not satisfied.
\end_layout

\begin_layout Standard
Further notes:
\end_layout

\begin_layout Itemize

\series bold
POST:
\series default
 This lets you update many documents at once.
 Your payload should be an array of values that would be sent via the singular
 resource POST, as described above, 
\emph on
however
\emph default
 you must also include an 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 for each value.
 The response will include all documents after their modification.
\end_layout

\begin_layout Itemize

\series bold
PUT:
\series default
 This is how you add documents to your MongoDB collection.
 Simply provide an array of values, and they will become MongoDB 
\begin_inset Quotes eld
\end_inset

insert
\begin_inset Quotes erd
\end_inset

 operations.
 The response will include 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 fields on all your documents, if you did not set them yourself.
\end_layout

\begin_layout Itemize

\series bold
DELETE:
\series default
 This is a MongoDB 
\begin_inset Quotes eld
\end_inset

remove
\begin_inset Quotes erd
\end_inset

 operation, 
\emph on
not
\emph default
 a 
\begin_inset Quotes eld
\end_inset

drop
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Accessing Your Resources over the Web
\end_layout

\begin_layout Standard
All your resources support the HTML format, so you can easily access them
 via a web browser.
 For example, this link: 
\begin_inset CommandInset href
LatexCommand href
target "http://localhost:8080/savory-example/data/users/4e057e94e799a23b0f581d7d/"

\end_inset

.
\end_layout

\begin_layout Standard
This view supports simple editing of your resources: you can POST, PUT any
 resource using JSON or XML payloads, or DELETE them.
 It's a great way to test and debug your resources.
\end_layout

\begin_layout Standard
You can customize this view as you please: just create 
\begin_inset Quotes eld
\end_inset

/savory/service/rest/singular.html
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

/savory/service/rest/plural.html
\begin_inset Quotes erd
\end_inset

 files in your 
\begin_inset Quotes eld
\end_inset

/fragments/
\begin_inset Quotes erd
\end_inset

 directory.
 You can start with the default files under your container's 
\begin_inset Quotes eld
\end_inset

/libraries/prudence/
\begin_inset Quotes erd
\end_inset

 directory as a template.
\end_layout

\begin_layout Subsubsection
Accessing Your Resources with the API
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "Prudence.Resources API"
target "http://threecrickets.com/javascript-api/?namespace=Prudence.Resources"

\end_inset

 makes it very easy to access your resources, whether internally or on a
 different node.
 See the API documentation for full details, otherwise here we'll provide
 you with a quick tutorial for using it with the REST Service.
\end_layout

\begin_layout Standard
Let's start with the internal use case:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/prudence/resources/')
\end_layout

\begin_layout Plain Layout

var user = Prudence.Resources.request({
\end_layout

\begin_layout Plain Layout

	uri: '/data/users/4e057e94e799a23b0f581d7d/',
\end_layout

\begin_layout Plain Layout

	internal: true
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

print(user.name)
\end_layout

\end_inset


\end_layout

\begin_layout Quote
Again, we'll emphasize that when accessing the API internally neither HTTP
 nor serialization are involved.
 The data is never converted to JSON, instead it's extracted directly from
 MongoDB's BSON to JavaScript's internal data structure, exactly as if you
 were using the 
\begin_inset CommandInset href
LatexCommand href
name "MongoDB API"
target "http://threecrickets.com/javascript-api/?namespace=MongoDB"

\end_inset

 directly.
 There's obviously some overhead added by the Prudence platform and the
 REST Service, but it should be very minimal, especially when compared to
 the network fetch from MongoDB.
 In short, performance concerns should not stop you from using the REST
 Service in this fashion.
\end_layout

\begin_layout Standard
Accessing remote resources is almost identical, though obviously HTTP and
 JSON (or XML) are involved.
 As an example, we can try to access our local resource via HTTP:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var user = Prudence.Resources.request({
\end_layout

\begin_layout Plain Layout

	uri: 'http://localhost:8080/myapp/data/users/4e057e94e799a23b0f581d7d/',
\end_layout

\begin_layout Plain Layout

	mediaType: 'application/json'
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

print(user.name)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, the URI can point to anywhere on the network, or the Internet.
 Note that we had to explicitly specify our preferred media type, because
 our resource supports several different formats.
\end_layout

\begin_layout Standard
The API can be used for all REST methods:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var user = Prudence.Resources.request({
\end_layout

\begin_layout Plain Layout

	uri: '/data/users/4e057e94e799a23b0f581d7d/',
\end_layout

\begin_layout Plain Layout

	internal: true,
\end_layout

\begin_layout Plain Layout

	method: 'post',
\end_layout

\begin_layout Plain Layout

	payload: {
\end_layout

\begin_layout Plain Layout

		value: {email: 'newemail@mysite.org'}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Remotely, the REST methods are actual HTTP verbs:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var user = Prudence.Resources.request({
\end_layout

\begin_layout Plain Layout

	uri: 'http://localhost:8080/myapp/data/users/4e057e94e799a23b0f581d7d/',
\end_layout

\begin_layout Plain Layout

	mediaType: 'application/json'
\end_layout

\begin_layout Plain Layout

	method: 'post',
\end_layout

\begin_layout Plain Layout

	payload: {
\end_layout

\begin_layout Plain Layout

		type: 'json',
\end_layout

\begin_layout Plain Layout

		value: {email: 'newemail@mysite.org'}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We'll finish off this short tutorial by showing you that for every request
 you can also set query params:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var users = Prudence.Resources.request({
\end_layout

\begin_layout Plain Layout

	uri: '/data/users/',
\end_layout

\begin_layout Plain Layout

	internal: true,
\end_layout

\begin_layout Plain Layout

	query: {
\end_layout

\begin_layout Plain Layout

		start: 5,
\end_layout

\begin_layout Plain Layout

		limit: 3
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

print(users[0].name)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Accessing Your Resources with cURL
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "cURL"
target "http://curl.haxx.se/"

\end_inset

 is an HTTP command line tool based on the cURL library, available for a
 great many Unix-like operating systems as well as Windows.
 It's especially useful for testing RESTful APIs.
 Here's a quick tutorial to get you started with using cURL with the REST
 Service.
\end_layout

\begin_layout Standard
First, a few GET commands to try:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl "http://localhost:8080/myapp/data/users/4e057e94e799a23b0f581d7d/?human=tru
e"
\end_layout

\begin_layout Plain Layout

curl "http://localhost:8080/myapp/data/users/4e057e94e799a23b0f581d7d/?format=xm
l&human=true"
\end_layout

\begin_layout Plain Layout

curl "http://localhost:8080/myapp/data/users/?limit=3&human=true"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can send a payload using the 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

 switch, which also sets the HTTP verb to POST.
 For example, this will modify the email of a user:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl -d '{"email":"newemail@mysite.org"}' "http://localhost:8080/myapp/data/users
/4e057e94e799a23b0f581d7d/?human=true"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When using 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

, you can also start your payload with 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

 to signify that you want to send the contents of a file, in this case 
\begin_inset Quotes eld
\end_inset

data.json
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl -d @data.json "http://localhost:8080/myapp/data/users/4e057e94e799a23b0f581d
7d/?human=true"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To set the HTTP verb explicitly, use 
\begin_inset Quotes eld
\end_inset

-X
\begin_inset Quotes erd
\end_inset

.
 Here we'll create a new user:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl -X PUT -d @data.json "http://localhost:8080/myapp/data/users/?human=true"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And now we'll delete a user:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl -X DELETE "http://localhost:8080/myapp/data/users/4e057e94e799a23b0f581d7d/
"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the 
\begin_inset Quotes eld
\end_inset

-h
\begin_inset Quotes erd
\end_inset

 switch, you can also send HTTP headers in raw form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl -H "Accept: application/xml" "http://localhost:8080/myapp/data/users/4e057e
94e799a23b0f581d7d/?human=true"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, add the 
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 switch to print out the outgoing and incoming headers.
\end_layout

\begin_layout Subsection
Extension
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Extended MongoDbResource
\end_layout

\begin_layout Subsubsection
Extending IterableResource
\end_layout

\begin_layout Section
RPC Service
\end_layout

\begin_layout Standard
The RPC (Remote Procedure Call) Service provides robust, elegant support
 for various versions of the 
\begin_inset CommandInset href
LatexCommand href
name "JSON-RPC"
target "http://groups.google.com/group/json-rpc/web/json-rpc-2-0"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "XML-RPC"
target "http://www.xmlrpc.com/spec"

\end_inset

 specifications, including support for batch processing for JSON-RPC 2.0.
 It's powerful enough that it may be in itself the primary reason why you
 wish to use Diligence.
\end_layout

\begin_layout Standard
In most cases, all you need to do is hookup your JavaScript functions to
 a URI, and let the RPC Service do the rest.
 All error codes, system APIs and type conversions will be properly handled.
\end_layout

\begin_layout Standard
As a bonus, the RPC Service also includes a nice client utility for calling
 JSON-RPC and XML-RPC.
\end_layout

\begin_layout Quote
Is RPC a good idea? We're inclined to say: no.
 REST is a much more scalable and robust pattern, all things considered.
 REST uses all the power of HTTP to provide client-cacheable representations.
 RPC, on the other hand, supports only HTTP POST, the only 
\emph on
non
\emph default
-idempotent HTTP operation, which can never be cached.
 However, RPC may be necessary for communication with other services and
 clients, so you might not have a choice.
 And, sometimes, it's just the most straightforward, quick-and-dirty solution
 to a problem.
 Especially with the Diligence RPC Service, it's so easy to just allow clients
 to call functions on the server, that sometimes you might prefer it to
 designing a RESTful URI-space.
 So be it! Just make sure you understand the pros and cons of you choice.
\end_layout

\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.RPC"
target "http://threecrickets.com/javascript-api/?namespace=Savory.RPC"

\end_inset

.
\end_layout

\begin_layout Standard
First, let's configure the URI-space in your application's 
\begin_inset Quotes eld
\end_inset

routing.js
\begin_inset Quotes erd
\end_inset

.
 Add the following to app.routes and app.dispatchers:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/calc/': {type: 'implicit', id: 'calc'}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.dispatchers = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	javascript: {library: '/resources/'}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now configure our resources in 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/rpc/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var Calc = {
\end_layout

\begin_layout Plain Layout

	multiply: function(x, y) {
\end_layout

\begin_layout Plain Layout

		return x * y
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	calc: new Diligence.RPC.Resource({namespaces: {Calc: Calc}})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And\SpecialChar \ldots{}
 that's pretty much it! You can now call your methods using JSON-RPC
 or XML-RPC.
\end_layout

\begin_layout Subsubsection
Namespaces
\end_layout

\begin_layout Standard
The key of the namespace is prefixed with a period before all method identifiers.
 So, our method above would be identified as 
\begin_inset Quotes eld
\end_inset

Calc.multiply
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
However, if you do not want this prefix, you can use the special 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 key, which here means the root namespace:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	calc: new Diligence.RPC.Resource({'.': Calc})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method would now be identified simply as 
\begin_inset Quotes eld
\end_inset

multiply
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
If you don't need the namespaces feature at all, you can use the following
 shortcut (note the 
\begin_inset Quotes eld
\end_inset

namespace
\begin_inset Quotes erd
\end_inset

 key, singular):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	calc: new Diligence.RPC.Resource({namespace: Calc})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Long Form
\end_layout

\begin_layout Standard
You have some more control over the exported functions, should you need
 it.
 The long form of creating namespaces is like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var Calc = {
\end_layout

\begin_layout Plain Layout

	multiply: {
\end_layout

\begin_layout Plain Layout

		fn: function(x, y) {
\end_layout

\begin_layout Plain Layout

			return x * y
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		arity: 2
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

artity
\begin_inset Quotes erd
\end_inset

 key counts how many arguments the function requires.
 If it's not there, the RPC Service will count them from the function spec.
 However, this won't work if you access JavaScript 
\begin_inset Quotes eld
\end_inset

arguments
\begin_inset Quotes erd
\end_inset

 directly, hence this long form exists.
\end_layout

\begin_layout Subsubsection
System Namespace
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

system
\begin_inset Quotes erd
\end_inset

 namespace is reserved for parts of the RPC protocols.
 The RPC Service implements these for you:
\end_layout

\begin_layout Itemize

\series bold
system.getCapabilities
\end_layout

\begin_layout Itemize

\series bold
system.listMethods
\end_layout

\begin_layout Itemize

\series bold
system.methodSignature
\end_layout

\begin_layout Itemize

\series bold
system.methodHelp:
\series default
 By default, this will just show the method name, but in the long form definitio
n you can add a 
\begin_inset Quotes eld
\end_inset

help
\begin_inset Quotes erd
\end_inset

 key to set this as you need.
\end_layout

\begin_layout Subsubsection
Scope
\end_layout

\begin_layout Standard
When your function is called, the 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 will be automatically populated with the following keys:
\end_layout

\begin_layout Itemize

\series bold
definition:
\series default
 Your long-form function definition (short-form function definitions will
 be expanded into the long form)
\end_layout

\begin_layout Itemize

\series bold
namespace:
\series default
 The original namespace object you supplied
\end_layout

\begin_layout Itemize

\series bold
resource:
\series default
 The Diligence.RPC.Resource instance
\end_layout

\begin_layout Itemize

\series bold
conversation:
\series default
 The Prudence conversation of the call
\end_layout

\begin_layout Itemize

\series bold
call:
\series default
 The RPC call object, as sent from the client
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

method
\begin_inset Quotes erd
\end_inset

 key is useful in that you can add anything you want to the method object.
 For a rather silly example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var Calc = {
\end_layout

\begin_layout Plain Layout

	multiply: {
\end_layout

\begin_layout Plain Layout

		fn: function(x, y) {
\end_layout

\begin_layout Plain Layout

			return x * y * this.definition.multiplyAll
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		multiplyAll: 100
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One special key is reserved: 
\begin_inset Quotes eld
\end_inset

scope
\begin_inset Quotes erd
\end_inset

.
 Use it to override 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 to be any value you desire:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var Calc = {
\end_layout

\begin_layout Plain Layout

	multiply: {
\end_layout

\begin_layout Plain Layout

		fn: function(x, y) {
\end_layout

\begin_layout Plain Layout

			return x * y * this
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		scope: 100
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you are using JavaScript object oriented programming, you might want
 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 to always just be the namespace object itself.
 In that case, you can use the 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 key instead of the 
\begin_inset Quotes eld
\end_inset

namespaces
\begin_inset Quotes erd
\end_inset

 key when creating your Diligence.RPC.Resource constructor.
 It works the same way as a namespace except that the scope will be the
 object itself for all method calls:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// This is a class
\end_layout

\begin_layout Plain Layout

var Calc = function(multiplyAll) {
\end_layout

\begin_layout Plain Layout

	this.multiplyAll = multiplyAll
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	this.multiply = function(x, y) {
\end_layout

\begin_layout Plain Layout

		return x * y * this.multiplyAll
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	calc: new Diligence.RPC.Resource({objects: {Calc: new Calc(100)}})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can mix 
\begin_inset Quotes eld
\end_inset

namespaces
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 in the same constructor.
 Also note that you can also use 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

 (singular) in the same way as 
\begin_inset Quotes eld
\end_inset

namespace
\begin_inset Quotes erd
\end_inset

 (singular).
\end_layout

\begin_layout Subsubsection
Fault Codes
\end_layout

\begin_layout Standard
If your function throws an exception, the RPC Service will return a ServerError
 fault code with the exception string as the message.
\end_layout

\begin_layout Standard
However, you can also return specific 
\begin_inset CommandInset href
LatexCommand href
name "XML-RPC fault codes"
target "http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php"

\end_inset

 (the same code numbers are used by JSON-RPC):
\end_layout

\begin_layout Itemize
By throwing a number (all fault codes are negative numbers).
 You can use the convenient constants in 
\begin_inset Quotes eld
\end_inset

Diligence.Fault
\begin_inset Quotes erd
\end_inset

.
 For example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

throw Diligence.Fault.InvalidParams
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
By throwing a dict with both the fault code and the message.
 For example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

throw {code: Diligence.Fault.InvalidParams, message: 'Cannot divide by 0!'}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Subsubsection
URI Query Parameters
\end_layout

\begin_layout Itemize

\series bold
type:
\series default
 The resource will automatically determine whether it should work in JSON-RPC
 or XML-RPC according to the media type of the incoming payload, or if that's
 not available, the preferred media type for the returned representation.
 Unfortunately, some clients don't or can't set either.
 In that case, you can set the type explicitly in the URI, with either 
\begin_inset Quotes eld
\end_inset

json
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

 as values.
\end_layout

\begin_layout Itemize

\series bold
human:
\series default
 Set this to 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 to generate multiline, indented human-readable results (both for JSON and
 XML).
 Great for debugging.
\end_layout

\begin_layout Subsubsection
Calling RPC with the API
\end_layout

\begin_layout Standard
The RPC Service includes a useful RPC client function, 
\begin_inset Quotes eld
\end_inset

Diligence.RPC.request
\begin_inset Quotes erd
\end_inset

.
 It's essentially a wrapper over the 
\begin_inset CommandInset href
LatexCommand href
name "Prudence.Resources API"
target "http://threecrickets.com/javascript-api/?namespace=Prudence.Resources"

\end_inset

 that builds the payload for you and nicely unpacks the results.
 The results will always be in JSON-RPC's format, even if you are using
 XML-RPC.
 This allows for uniform processing on your end.
\end_layout

\begin_layout Standard
Here's an example of an internal call using JSON-RPC:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/rpc/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var result = Diligence.RPC.request({
\end_layout

\begin_layout Plain Layout

	uri: '/calc/',
\end_layout

\begin_layout Plain Layout

	internal: true,
\end_layout

\begin_layout Plain Layout

	name: 'Calc.multiply',
\end_layout

\begin_layout Plain Layout

	params: [5, 6],
\end_layout

\begin_layout Plain Layout

	id: 'abc',
\end_layout

\begin_layout Plain Layout

	protocol: 'json'
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (result.error) {
\end_layout

\begin_layout Plain Layout

	print('Error: ' + result.error.message)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	print(result.result)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For XML-RPC, simply set 
\begin_inset Quotes eld
\end_inset

protocol
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

xml
\begin_inset Quotes erd
\end_inset

.
 If not provided, it defaults to 
\begin_inset Quotes eld
\end_inset

json
\begin_inset Quotes erd
\end_inset

.
 Note that the result will also include that 
\begin_inset Quotes eld
\end_inset

protocol
\begin_inset Quotes erd
\end_inset

 key you provided, in case you need to know which protocol was used.
\end_layout

\begin_layout Standard
Generally, if you have the option to use JSON-RPC, you should prefer it.
 XML serialization incurs an extra overhead in JavaScript.
\end_layout

\begin_layout Subsubsection
Calling RPC with cURL
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "cURL"
target "http://curl.haxx.se/"

\end_inset

 is an HTTP command line tool based on the cURL library, available for a
 great many Unix-like operating systems as well as Windows.
 It's especially useful for testing RESTful APIs.
 Here's a quick tutorial to get you started with using cURL with the RPC
 Service.
\end_layout

\begin_layout Standard
First, let's create our payload.
 With a text editor, create a file named 
\begin_inset Quotes eld
\end_inset

rpc.json
\begin_inset Quotes erd
\end_inset

 and paste this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"jsonrpc": "2.0",
\end_layout

\begin_layout Plain Layout

	"method": "Calc.multiply",
\end_layout

\begin_layout Plain Layout

	"params": [2, 3],
\end_layout

\begin_layout Plain Layout

	"id": "abc"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can send a payload using the 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

 switch, which also sets the HTTP verb to POST.
 When using 
\begin_inset Quotes eld
\end_inset

-d
\begin_inset Quotes erd
\end_inset

, you can also start your payload with 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

 to signify that you want to send the contents of a file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl -d @rpc.json "http://localhost:8080/myapp/calc/?type=json&human=true"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You should get this result:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"id": "abc",
\end_layout

\begin_layout Plain Layout

	"result": "6",
\end_layout

\begin_layout Plain Layout

	"error": null,
\end_layout

\begin_layout Plain Layout

	"jsonrpc": "2.0"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Calling RPC from Web Browsers
\end_layout

\begin_layout Standard
Many client-side JavaScript frameworks include support for RPC, but if all
 you need is a straightforward, self-contained library, we recommend 
\begin_inset CommandInset href
LatexCommand href
name "jsonrpcjs"
target "https://github.com/gimmi/jsonrpcjs"

\end_inset

.
\end_layout

\begin_layout Section
Search Service
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Search"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Search"

\end_inset

.
\end_layout

\begin_layout Section
Serials Service
\end_layout

\begin_layout Standard
This straightforward service generates unique integers in a series, using
 MongoDB atomic operations.
 No number in a specific series will ever be generated again.
 This service is thus useful for generating integer IDs.
\end_layout

\begin_layout Standard
Note that uniqueness is only guaranteed by the intactness of the MongoDB
 database.
 If you somehow lose it and have to start over, there's a chance you would
 regenerate IDs that have already been used.
 If you need unique IDs that don't have this limitation, you'll want to
 use GUIDs instead.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Serials"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Serials"

\end_inset

.
\end_layout

\begin_layout Standard
Usage is very simple:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/service/serials/')
\end_layout

\begin_layout Plain Layout

var id = Diligence.Serials.next('person')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each series is stored as a single document in the 
\begin_inset Quotes eld
\end_inset

serials
\begin_inset Quotes erd
\end_inset

 MongoDB collection.
 By default, the method will create the series document if it does not yet
 exist, initializing it with the number 1.
\end_layout

\begin_layout Section
Syndication Service
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Syndication"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Syndication"

\end_inset

.
\end_layout

\begin_layout Subsection
Links
\end_layout

\begin_layout Standard
The module contains a simple /web/fragments/ drop-in that adds links recognizes
 by all major browsers, and another drop-in for the 
\begin_inset Quotes eld
\end_inset

syndication
\begin_inset Quotes erd
\end_inset

 button, using the 
\emph on
de facto
\emph default
 standard icon.
\end_layout

\begin_layout Section
Gravatar Integration
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Gravatar"
target "http://en.gravatar.com/"

\end_inset

 is a popular service for managing user avatars and simple profile pages
 by associating them with email addresses.
\end_layout

\begin_layout Standard
It makes users happy, because they can manage their avatars for many, many
 services in one place.
 The user's email is hashed so that it is not made publicly available, unless
 the user chooses to put them explicitly on their profile.
\end_layout

\begin_layout Standard
It makes site owners happy, because they can display avatars for users without
 having to store them or otherwise manage them.
 Additionally, new users would have their avatar immediately displayed without
 any effort on their part, and users do not like effort.
 If you're using the <a href="../../service/authentication/">Authentication
 Module</a> in association with the <a href="../../feature/registration/">Registrati
on Module</a>, then you already have an email address for the user, and
 can immediately fetch their avatar from Gravatar.
\end_layout

\begin_layout Standard
Worried about forcing users to use an external service? Then make Gravatar
 an optional fallback.
 Provide users with a way to manage avatars on your site directly, and only
 default to Gravatar.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Gravatar"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Gravatar"

\end_inset

.
\end_layout

\begin_layout Standard
Just enter an email address, and let the Diligence magic happen.
\end_layout

\begin_layout Standard
The avatar above is hyperlinked to their Gravatar profile page.
 And here's the complete JSON dump of their profile:
\end_layout

\begin_layout Section
PayPal Integration
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.PayPal"
target "http://threecrickets.com/javascript-api/?namespace=Savory.PayPal"

\end_inset

.
\end_layout

\begin_layout Section
Sencha Integration
\end_layout

\begin_layout Standard
Ext JS and Sencha Touch are both large JavaScript frameworks in their own
 right, and Diligence supports many of their features.
 For this reason, we've divided the section for Sencha Integration into
 several sub-sections.
 Still, you'll want to start here, where we go over some general usage applicabl
e to all features.
\end_layout

\begin_layout Standard
After that, go ahead and read the sections for the following integration
 features:
\end_layout

\begin_layout Itemize
Grids
\end_layout

\begin_layout Itemize
Trees
\end_layout

\begin_layout Itemize
Charts
\end_layout

\begin_layout Itemize
Forms
\end_layout

\begin_layout Itemize
Ext Direct
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Sencha"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Sencha"

\end_inset

.
\end_layout

\begin_layout Standard
To include Ext JS in your HTML page, you'll want to insert a scriptlet,
 resulting in a page template similar to this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<head>
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

Diligence.Sencha.extJsHead(conversation, 'ext-all-gray')
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

</head>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

Ext.onReady(function() {
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes:
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

extJsHead
\begin_inset Quotes erd
\end_inset

 method uses 
\begin_inset Quotes eld
\end_inset

conversation.pathToBase
\begin_inset Quotes erd
\end_inset

 to make sure that the correct relative URL is inserted.
 Be aware of this if you intend to cache that fragment for all URLs.
\end_layout

\begin_layout Itemize
The second argument is the theme: it will be 
\begin_inset Quotes eld
\end_inset

ext-all
\begin_inset Quotes erd
\end_inset

 if not provided.
\end_layout

\begin_layout Itemize
This also includes Diligence's Ext JS client-side helper library.
 You don't have to use it, but it can make your life easier.
 You can find it under 
\begin_inset Quotes eld
\end_inset

/libraries/web/scripts/savory/integration/ext-js.js
\begin_inset Quotes erd
\end_inset

.
 The library enhances Ext JS via:
\end_layout

\begin_deeper
\begin_layout Itemize
JSON Readers and Writers that support MongoDB's extended JSON format.
 This will allow you to automatically translate $date, $long and other JSON
 extensions.
 Even without using MongoDB, this is a very useful format.
\end_layout

\begin_layout Itemize
A data Proxy that automatically uses the extended JSON Reader and Writer,
 and builds URLs in Diligence's default structure.
\end_layout

\end_deeper
\begin_layout Section
Sencha Integration: Grids
\end_layout

\begin_layout Standard
Ext JS's grid widget may be its most powerful feature.
 It supports editing, paging and endless scrolling, with lots of room for
 customization.
 Grids offer a familiar and powerful UI for traversing large amounts of
 structured data.
 Diligence offers excellent server-side support for this astounding client
 widget: in a few lines of code, you can hook up an editable grid widget
 to a MongoDB collection.
\end_layout

\begin_layout Standard
Despite being one of Diligence's most immediately impressive features, this
 is going to be a rather short manual chapter! The reason is that the heavy
 lifting is done by the REST Service.
 The URI-space created by the REST Service is compatible with Ext JS, so
 there's not much more to do other than hook up the grid using client-side
 JavaScript.
\end_layout

\begin_layout Standard
What we're going to do here is give a quick tutorial for using Ext JS grids
 with Diligence.
\end_layout

\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
See the REST Service.
 Resources created there are immediately attachable to Ext JS grids.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "server-side API documentation for Savory.Sencha"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Sencha"

\end_inset

 and the 
\begin_inset CommandInset href
LatexCommand href
name "client-side API documentation for Ext JS"
target "http://docs.sencha.com/ext-js/4-1/"

\end_inset

.
\end_layout

\begin_layout Standard
A full tutorial of Ext JS grids is beyond what we can do in this Manual,
 but here are is a quick overview of the components as they apply to Diligence:
\end_layout

\begin_layout Itemize
You start by creating a 
\begin_inset CommandInset href
LatexCommand href
name "Model class"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.data.Model"

\end_inset

, which is a template for your 
\begin_inset Quotes eld
\end_inset

records,
\begin_inset Quotes erd
\end_inset

 represented by your grid rows.
 Each model has a list of typed fields (the default is a plain string) which
 imply client-side translation and validation.
 You can further create your custom fields.
 For Diligence, it's important that you include the 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 field and also set 
\begin_inset Quotes eld
\end_inset

idProperty
\begin_inset Quotes erd
\end_inset

 to be that field.
 If you don't explicitly set 
\begin_inset Quotes eld
\end_inset

idProperty,
\begin_inset Quotes erd
\end_inset

 Ext JS will not be able to save individual records.
 Also not that Ext JS requires the idProperty to be a primitive, so we are
 using the 
\begin_inset Quotes eld
\end_inset

stringid
\begin_inset Quotes erd
\end_inset

 mode for the Diligence REST Service in order to make sure we get strings,
 not MongoDB ObjectIds.
\end_layout

\begin_layout Itemize
The model also defines a 
\begin_inset CommandInset href
LatexCommand href
name "Proxy,"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.data.proxy.Proxy"

\end_inset

 which is Ext JS's extensible connector class.
 Proxies are in charge of loading and saving the data.
 In this case, we are using a 
\begin_inset Quotes eld
\end_inset

savory
\begin_inset Quotes erd
\end_inset

 proxy type.
 This is a custom type that we have defined in Diligence's Ext JS helper
 library.
 It's rather simple, and you are free to use the 
\begin_inset Quotes eld
\end_inset

ajax
\begin_inset Quotes erd
\end_inset

 proxy type instead with the modifications we've made there.
 The 
\begin_inset Quotes eld
\end_inset

savory
\begin_inset Quotes erd
\end_inset

 proxy is configured to automatically support MongoDB's extended JSON notation
 and also use Diligence's URL style.
 We've additionally set the 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 property for the reader to 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "Store"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.data.Store"

\end_inset

 is an intermediary class between the model and the grid.
 It handles caching of model instances (
\begin_inset Quotes eld
\end_inset

records
\begin_inset Quotes erd
\end_inset

) in memory, paging, pre-fetching, etc.
 By default it will use the proxy we defined in our model.
\end_layout

\begin_layout Itemize
Finally, there's the 
\begin_inset CommandInset href
LatexCommand href
name "grid panel"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.grid.Panel"

\end_inset

.
 Though we've defined 
\begin_inset Quotes eld
\end_inset

fields
\begin_inset Quotes erd
\end_inset

 in our model, we must define 
\begin_inset Quotes eld
\end_inset

columns
\begin_inset Quotes erd
\end_inset

 in our grid that map onto the fields.
 In many cases we'll be doing a one-to-one mapping, but you can create custom
 columns that transform the model in various ways, for example combining
 fields into a single column, or having a column that is derived from other
 fields.
 You do not have to have a column for every field.
 (Indeed, you'd likely not want to have the 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 field visible.)
\end_layout

\begin_layout Itemize
By default, the grid is not editable, but we can add the 
\begin_inset CommandInset href
LatexCommand href
name "CellEditing"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.grid.plugin.CellEditing"

\end_inset

 plugin to handle that.
 Every column can define its own editor, which can handle user-side validation
 beyond what is offered by the model.
 Ext JS comes with many powerful editing widgets, and of course you can
 create your own.
\end_layout

\begin_layout Itemize
In this example, we've also added a 
\begin_inset CommandInset href
LatexCommand href
name "paging toolbar"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.toolbar.Paging"

\end_inset

 to the grid, and hooked it up to use the same store as the grid.
 As the store is paged by the toolbar, it fires events that update the current
 grid view.
\end_layout

\begin_layout Standard
That should be enough to get you started.
 Here's how the code looks:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<head>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

Diligence.Sencha.extJsHead(conversation)
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

</head>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

	<div id="grid"></div>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

Ext.onReady(function() {
\end_layout

\begin_layout Plain Layout

	var pageSize = 15;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Ext.define('User', {
\end_layout

\begin_layout Plain Layout

		extend: 'Ext.data.Model',
\end_layout

\begin_layout Plain Layout

		fields: [
\end_layout

\begin_layout Plain Layout

			'_id',
\end_layout

\begin_layout Plain Layout

			'name',
\end_layout

\begin_layout Plain Layout

			{name: 'lastSeen', type: 'date'}
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		idProperty: '_id',
\end_layout

\begin_layout Plain Layout

		proxy: {
\end_layout

\begin_layout Plain Layout

			type: 'savory',
\end_layout

\begin_layout Plain Layout

			url: '<%= conversation.pathToBase %>/data/users/'
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	var store = Ext.create('Ext.data.Store', {
\end_layout

\begin_layout Plain Layout

		model: 'User',
\end_layout

\begin_layout Plain Layout

		pageSize: pageSize,
\end_layout

\begin_layout Plain Layout

		autoSync: true,
\end_layout

\begin_layout Plain Layout

		autoLoad: true
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Ext.create('Ext.grid.Panel', {
\end_layout

\begin_layout Plain Layout

		store: store,
\end_layout

\begin_layout Plain Layout

		columns: [{
\end_layout

\begin_layout Plain Layout

			dataIndex: 'name',
\end_layout

\begin_layout Plain Layout

			header: 'Name',
\end_layout

\begin_layout Plain Layout

			editor: 'textfield'
\end_layout

\begin_layout Plain Layout

		}, {
\end_layout

\begin_layout Plain Layout

			dataIndex: 'lastSeen',
\end_layout

\begin_layout Plain Layout

			xtype: 'datecolumn',
\end_layout

\begin_layout Plain Layout

			format: 'm/d/y, H:i',
\end_layout

\begin_layout Plain Layout

			header: 'Last Seen',
\end_layout

\begin_layout Plain Layout

			editor: {
\end_layout

\begin_layout Plain Layout

				xtype: 'datefield',
\end_layout

\begin_layout Plain Layout

				format: 'm/d/y, H:i'
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}],
\end_layout

\begin_layout Plain Layout

		forceFit: true,
\end_layout

\begin_layout Plain Layout

		selType: 'cellmodel',
\end_layout

\begin_layout Plain Layout

		plugins: [
\end_layout

\begin_layout Plain Layout

			Ext.create('Ext.grid.plugin.CellEditing', {clicksToEdit: 2})
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		dockedItems: [{
\end_layout

\begin_layout Plain Layout

			dock: 'bottom',
\end_layout

\begin_layout Plain Layout

			xtype: 'pagingtoolbar',
\end_layout

\begin_layout Plain Layout

			store: store,
\end_layout

\begin_layout Plain Layout

		}],
\end_layout

\begin_layout Plain Layout

		renderTo: 'grid',
\end_layout

\begin_layout Plain Layout

		style: {
\end_layout

\begin_layout Plain Layout

			margin: 'auto'
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		width: 500,
\end_layout

\begin_layout Plain Layout

		height: 370
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sencha Integration: Trees
\end_layout

\begin_layout Standard
Ext JS's tree widget is quite powerful, and gives you a lot of control over
 the visual presentation, supporting complex nodes and multi-column displays.
 Though it's not in itself editable, it integrates with Ext JS's drag-and-drop
 model, which you can hook up into your custom editing model.
 Diligence offers excellent server-side support for it: in a few lines of
 code, you can hook up a tree widget to a document MongoDB collection, and
 use MongoDB 
\begin_inset CommandInset href
LatexCommand href
name "DBRefs"
target "http://docs.mongodb.org/manual/applications/database-references/"

\end_inset

 to expand the tree into other documents.
\end_layout

\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "server-side API documentation for Savory.Sencha"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Sencha"

\end_inset

 and the 
\begin_inset CommandInset href
LatexCommand href
name "client-side API documentation for Ext JS"
target "http://docs.sencha.com/ext-js/4-1/"

\end_inset

.
\end_layout

\begin_layout Standard
The Ext JS's tree requires a rather specific JSON data representation, so
 we've inherited the resource class in the REST Service to support it, with
 classes 
\begin_inset Quotes eld
\end_inset

Diligence.Sencha.TreeResource
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Diligence.Sencha.MongoDbTreeResource.
\begin_inset Quotes erd
\end_inset

 You might want to start by reading the REST Service manual chapter.
\end_layout

\begin_layout Standard
In your 
\begin_inset Quotes eld
\end_inset

/routing.js
\begin_inset Quotes erd
\end_inset

, add the following to app.routes and app.dispatchers:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

app.routes = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	'/data/textpack/{id}/': {type: 'implicit', id: 'textpack'}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

app.dispatchers = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	javascript: {library: '/resources/'}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the 
\begin_inset Quotes eld
\end_inset

{id}
\begin_inset Quotes erd
\end_inset

 variable in the URI pattern: the resource expects the node ID to appear
 there.
\end_layout

\begin_layout Standard
Now add a 
\begin_inset Quotes eld
\end_inset

MongoDbTreeResource
\begin_inset Quotes erd
\end_inset

 to your 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	textpack: new Diligence.Sencha.MongoDbTreeResource({collection: 'textpacks'})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Custom Queries
\end_layout

\begin_layout Standard
In the above example, the 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 segment in the URI will be used for a MongoDB 
\begin_inset Quotes eld
\end_inset

findOne
\begin_inset Quotes erd
\end_inset

 operation in the collection for the document 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

, and the entire document (minus the 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 field) will be used for the tree data.
 However, Diligence allows you to customize this data search and extraction:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	textpack: new Diligence.Sencha.MongoDbTreeResource({collection: 'textpacks',
 query: {locale: 'en'}, field: 'text'})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

query
\begin_inset Quotes erd
\end_inset

 key will be used for the MongoDB 
\begin_inset Quotes eld
\end_inset

findOne
\begin_inset Quotes erd
\end_inset

 operation, and the 
\begin_inset Quotes eld
\end_inset

field
\begin_inset Quotes erd
\end_inset

 key specifies which field in the document contains the tree data.
\end_layout

\begin_layout Subsubsection
Custom Text
\end_layout

\begin_layout Standard
By default, the text for each node will be the key for tree folders and
 the stringified value for tree leaves.
 But, you can customize this by overriding the 
\begin_inset Quotes eld
\end_inset

getNodeText
\begin_inset Quotes erd
\end_inset

 method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	textpack: new Diligence.Sencha.MongoDbTreeResource({
\end_layout

\begin_layout Plain Layout

		collection: 'textpacks',
\end_layout

\begin_layout Plain Layout

		query: {locale: 'en'},
\end_layout

\begin_layout Plain Layout

		field: 'text',
\end_layout

\begin_layout Plain Layout

		getNodeText: function(id, node) {
\end_layout

\begin_layout Plain Layout

			return typeof node == 'string' ? id + ': ' + node : id
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 argument is the key, while the 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

 argument is null for tree folders or the value for tree leaves.
\end_layout

\begin_layout Subsubsection
Data Structure
\end_layout

\begin_layout Standard
The expected document data structure is quite straightforward: a series
 of nested dicts, for which non-dict keys become tree leaves.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"_id": {
\end_layout

\begin_layout Plain Layout

		"$oid": "4d474457f9e399e7e05e1269"
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"text": {
\end_layout

\begin_layout Plain Layout

		"application": {
\end_layout

\begin_layout Plain Layout

			"title": "MyApp",
\end_layout

\begin_layout Plain Layout

			"description": "This is an important application"
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"locale": "en"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, 
\begin_inset Quotes eld
\end_inset

text
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

application
\begin_inset Quotes erd
\end_inset

 will both become tree folders, while 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

description
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

locale
\begin_inset Quotes erd
\end_inset

 will become tree leaves.
 The 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 field will be ignored by 
\begin_inset Quotes eld
\end_inset

MongoDbTreeResource
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Multi-Document Data Structure
\end_layout

\begin_layout Standard
The tree data can be split among several documents using MongoDB 
\begin_inset CommandInset href
LatexCommand href
name "DBRefs"
target "http://docs.mongodb.org/manual/applications/database-references/"

\end_inset

.
 Diligence will fetch the referred document and use the 
\begin_inset Quotes eld
\end_inset

field
\begin_inset Quotes erd
\end_inset

 key, if it was set, to retrieve a specific field.
 This can continue recursively to any depth.
\end_layout

\begin_layout Standard
Let's add a DBRef (using MongoDB's extended JSON notation, via the 
\begin_inset Quotes eld
\end_inset

$ref
\begin_inset Quotes erd
\end_inset

 key) to another document in our collection:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"_id": {
\end_layout

\begin_layout Plain Layout

		"$oid": "4d474457f9e399e7e05e1269"
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"text": {
\end_layout

\begin_layout Plain Layout

		"application": {
\end_layout

\begin_layout Plain Layout

			"title": "MyApp",
\end_layout

\begin_layout Plain Layout

			"description": "This is an important application",
\end_layout

\begin_layout Plain Layout

			"more": {
\end_layout

\begin_layout Plain Layout

				"$ref": "textpacks",
\end_layout

\begin_layout Plain Layout

				"$id": "4d6831f97c6c99e71b8eaf0e"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"locale": "en"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The DBRef node will appear in the tree as a non-expanded folder so that
 the user will have to explicitly expand it in order to fetch the nodes
 underneath.
 If you require all nodes to be expanded, you can call 
\begin_inset Quotes eld
\end_inset

expandAll
\begin_inset Quotes erd
\end_inset

 on the tree after it is loaded.
\end_layout

\begin_layout Subsubsection
In-Memory Data
\end_layout

\begin_layout Standard
As with the REST Service, you can also avoid MongoDB and create an in-memory
 tree resource:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var textpack = {
\end_layout

\begin_layout Plain Layout

	application: {
\end_layout

\begin_layout Plain Layout

		title: 'MyApp',
\end_layout

\begin_layout Plain Layout

		description: 'This is an important application'
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	textpack: new Diligence.Sencha.InMemroyTreeResource({tree: textpack})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that there is no distributed version of this, because it's unnecessary:
 the tree data is read-only, so there's no reason to synchronize the data
 across the cluster.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Subsubsection
URI-space
\end_layout

\begin_layout Standard
Tree widgets are read-only, so the 
\begin_inset Quotes eld
\end_inset

MongoDbTreeResource
\begin_inset Quotes erd
\end_inset

 is significantly simpler to implement than 
\begin_inset Quotes eld
\end_inset

MongoDbResource
\begin_inset Quotes erd
\end_inset

.
 It only handles HTTP GET.
 Moreover, since this resource is designed for Ext JS, it only supports
 JSON, not XML.
 The only URI query parameter supported is 
\begin_inset Quotes eld
\end_inset

human=true
\begin_inset Quotes erd
\end_inset

, to return multiline, indented JSON representations.
\end_layout

\begin_layout Standard
What is a bit more complicated here is the node ID pattern.
 To support the recursive nature of the tree, the node ID is constructed
 using the path of the node starting at the root, with 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 as a separator.
 The root node is simply 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

.
 (These constants are configurable.)
\end_layout

\begin_layout Standard
To show how this works, let's lay out all the node IDs from the example
 data structure provided above:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/
\end_layout

\begin_layout Plain Layout

/text
\end_layout

\begin_layout Plain Layout

/text/application
\end_layout

\begin_layout Plain Layout

/text/application/title
\end_layout

\begin_layout Plain Layout

/text/application/description
\end_layout

\begin_layout Plain Layout

/locale
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that when include the node ID in the URI, you have to URI-encode it.
 The URI-code for a 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

%2f
\begin_inset Quotes erd
\end_inset

.
 As an example, let's fetch a node using cURL in the command line:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

curl "http://localhost:8080/myapp/data/textpack/%2ftext%2fapplication/?human=tru
e"
\end_layout

\end_inset


\end_layout

\begin_layout Quote
If you are using Apache to reverse-proxy to your server, you may find that
 it does not proxy URLs with a 
\begin_inset Quotes eld
\end_inset

%2f
\begin_inset Quotes erd
\end_inset

.
 To solve this problem, you need to add the 
\begin_inset Quotes eld
\end_inset

AllowEncodedSlashes NoDecode
\begin_inset Quotes erd
\end_inset

 directive, and also add the 
\begin_inset Quotes eld
\end_inset

nocanon
\begin_inset Quotes erd
\end_inset

 attribute to your 
\begin_inset Quotes eld
\end_inset

ProxyPass
\begin_inset Quotes erd
\end_inset

 directive.
 For more information, see 
\begin_inset CommandInset href
LatexCommand href
name "this discussion"
target "http://stackoverflow.com/questions/4390436/need-to-allow-encoded-slashes-on-apache"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Tree Widget
\end_layout

\begin_layout Standard
A full tutorial of Ext JS trees is beyond what we can do in this Manual,
 but here are is a quick overview of the components as they apply to Diligence:
\end_layout

\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "TreeStore"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.data.TreeStore"

\end_inset

 is manages data for the tree.
 It handles caching of tree node instances in memory.
 Note that we've set 
\begin_inset Quotes eld
\end_inset

defaultRootId
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

, instead of the default 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

.
 This is to match Diligence's path-based node ID pattern (see above).
\end_layout

\begin_layout Itemize
The store also defines a 
\begin_inset CommandInset href
LatexCommand href
name "Proxy,"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.data.proxy.Proxy"

\end_inset

 which is Ext JS's extensible connector class.
 Proxies are in charge of loading the data.
 In this case, we are using a 
\begin_inset Quotes eld
\end_inset

savory
\begin_inset Quotes erd
\end_inset

 proxy type.
 This is a custom type that we have defined in Diligence's Ext JS helper
 library.
 It's rather simple, and you are free to use the 
\begin_inset Quotes eld
\end_inset

ajax
\begin_inset Quotes erd
\end_inset

 proxy type instead with the modifications we've made there.
 The 
\begin_inset Quotes eld
\end_inset

savory
\begin_inset Quotes erd
\end_inset

 proxy is configured to automatically support MongoDB's extended JSON notation
 and also use Diligence's URL style.
 We've additionally set the 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 property for the reader to 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 (where the node's children will be found).
\end_layout

\begin_layout Itemize
Finally, there's the 
\begin_inset CommandInset href
LatexCommand href
name "tree panel"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.tree.Panel"

\end_inset

, which is linked to the store.
\end_layout

\begin_layout Standard
That should be enough to get you started.
 Here's how the code looks:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<head>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

Diligence.Sencha.extJsHead(conversation)
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

</head>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

	<div id="tree"></div>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

Ext.onReady(function() {
\end_layout

\begin_layout Plain Layout

	var store = Ext.create('Ext.data.TreeStore', {
\end_layout

\begin_layout Plain Layout

		proxy: {
\end_layout

\begin_layout Plain Layout

			type: 'savory',
\end_layout

\begin_layout Plain Layout

			url: '<%= conversation.pathToBase %>/data/textpack/'
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		defaultRootId: '/',
\end_layout

\begin_layout Plain Layout

		autoLoad: true
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Ext.create('Ext.tree.Panel', {
\end_layout

\begin_layout Plain Layout

		store: store,
\end_layout

\begin_layout Plain Layout

		autoScroll: true,
\end_layout

\begin_layout Plain Layout

		useArrows: true,
\end_layout

\begin_layout Plain Layout

		rootVisible: false,
\end_layout

\begin_layout Plain Layout

		renderTo: 'tree',
\end_layout

\begin_layout Plain Layout

		style: {
\end_layout

\begin_layout Plain Layout

			margin: 'auto'
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		width: 500,
\end_layout

\begin_layout Plain Layout

		height: 400
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sencha Integration: Charts
\end_layout

\begin_layout Standard
Hi!
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Hi!
\end_layout

\begin_layout Section
Sencha Integration: Forms
\end_layout

\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
We're using the Diligence Forms Service, so follow the instructions there.
\end_layout

\begin_layout Standard
The different is that you should use the 
\begin_inset Quotes eld
\end_inset

Diligence.Sencha.Form
\begin_inset Quotes erd
\end_inset

 class instead of 
\begin_inset Quotes eld
\end_inset

Diligence.Forms.Form
\begin_inset Quotes erd
\end_inset

.
 The former class extends the latter class with an extra method to better
 integrate with Ext JS.
\end_layout

\begin_layout Standard
So, in 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	multiply: new Diligence.Sencha.Form(multiplyForm)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Subsubsection
Configuring the Form Fields
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

toExtJs
\begin_inset Quotes erd
\end_inset

 method lets you generate the correct client-side source code for configuring
 fields for the Ext JS form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/forms/')
\end_layout

\begin_layout Plain Layout

var form = Diligence.Forms.getForm('/multiply/')
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

var fields = <%= form.toExtJs(conversation) %>;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the difference between server-side and client-side JavaScript here!
\end_layout

\begin_layout Standard
The field configurations include the following, if they were set up for
 the field:
\end_layout

\begin_layout Itemize
The masking regular expression.
\end_layout

\begin_layout Itemize
The client-side validation function.
\end_layout

\begin_layout Itemize
Internationalization text strings for field labels and possible client-side
 validation error messages.
\end_layout

\begin_layout Standard
You can explicitly disable these like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var fields = <%= form.toExtJs(conversation, {clientValidation: false, clientMaski
ng: false}) %>;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Internationalization will use text pack stored in the conversation, or you
 can set one explicitly:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

var textPack = Diligence.Internationalization.getPack('fr')
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

var fields = <%= form.toExtJs(conversation, {textPack: textPack}) %>;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
AJAX Forms
\end_layout

\begin_layout Standard
A full tutorial of Ext JS forms is beyond what we can do in this Manual,
 but here are is a quick example of how you could create an AJAX form to
 use with Diligence:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<head>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

Diligence.Sencha.extJsHead(conversation)
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

</head>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/forms/')
\end_layout

\begin_layout Plain Layout

var form = Diligence.Forms.getForm('/multiply/')
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

var fields = <%= form.toExtJs(conversation) %>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Ext.onReady(function() {
\end_layout

\begin_layout Plain Layout

	Ext.create('Ext.window.Window', {
\end_layout

\begin_layout Plain Layout

		title: 'MyForm',
\end_layout

\begin_layout Plain Layout

		width: 350,
\end_layout

\begin_layout Plain Layout

		items: {
\end_layout

\begin_layout Plain Layout

			xtype: 'form',
\end_layout

\begin_layout Plain Layout

			url: '<%= conversation.pathToBase %>/multiply/?mode=json',
\end_layout

\begin_layout Plain Layout

			border: false,
\end_layout

\begin_layout Plain Layout

			bodyCls: 'x-border-layout-ct', // Uses the neutral background color
\end_layout

\begin_layout Plain Layout

			bodyPadding: 10,
\end_layout

\begin_layout Plain Layout

			layout: 'anchor',
\end_layout

\begin_layout Plain Layout

			defaults: {
\end_layout

\begin_layout Plain Layout

				anchor: '100%'
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			defaultType: 'textfield',
\end_layout

\begin_layout Plain Layout

			items: fields,
\end_layout

\begin_layout Plain Layout

			buttons: [{
\end_layout

\begin_layout Plain Layout

				text: 'Submit',
\end_layout

\begin_layout Plain Layout

				disabled: true,
\end_layout

\begin_layout Plain Layout

				formBind: true,
\end_layout

\begin_layout Plain Layout

				handler: function() {
\end_layout

\begin_layout Plain Layout

					var form = this.up('form').getForm();
\end_layout

\begin_layout Plain Layout

					if (form.isValid()) {
\end_layout

\begin_layout Plain Layout

						form.submit({
\end_layout

\begin_layout Plain Layout

							success: function(form, action) {
\end_layout

\begin_layout Plain Layout

								Ext.Msg.alert('Success!', action.result.msg);
\end_layout

\begin_layout Plain Layout

							},
\end_layout

\begin_layout Plain Layout

							failure: function(form, action) {
\end_layout

\begin_layout Plain Layout

								Ext.Msg.alert('Failure!', action.result.msg);
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

						});
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}]
\end_layout

\begin_layout Plain Layout

	}).show();
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Standard Forms
\end_layout

\begin_layout Standard
Ext JS can also perform a standard submission instead of using AJAX.
 The result is that you get the nice GUI of Ext JS, including client-side
 validation, but as far as the server is concerned, the behavior is like
 the standard HTML <form> mechanism.
\end_layout

\begin_layout Standard
Why would want to do this? Honestly, with Diligence handling AJAX forms
 for you, it's hard to imagine a use case.
 Nevertheless, we'll tell you how to do this, for completion's sake.
\end_layout

\begin_layout Standard
Let's use the Diligence Form Service's manual mode:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/service/forms/')
\end_layout

\begin_layout Plain Layout

var form = Diligence.Forms.getForm('/multiply/')
\end_layout

\begin_layout Plain Layout

var results = form.handle(conversation)
\end_layout

\begin_layout Plain Layout

%>
\end_layout

\begin_layout Plain Layout

var fields = <%= form.toExtJs(conversation, {results: results}) %>;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note how we added 
\begin_inset Quotes eld
\end_inset

results
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

toExtJs
\begin_inset Quotes erd
\end_inset

.
 This makes sure that the fields will be initialized with the previous form
 submission values, and also the correct error codes for field validation.
\end_layout

\begin_layout Subsubsection
Ext Direct Forms
\end_layout

\begin_layout Standard
Finally, Ext JS forms can also use Ext Direct, Sencha's RPC mechanism, which
 is nicely supported by Diligence, instead of the regular AJAX mode.
 Going this route means that you will not use the Diligence Forms Service
 at all, and use the Diligence RPC Service instead.
\end_layout

\begin_layout Standard
We recommend using the Diligence Forms Service if you can, because it will
 give you fuller control over field validation.
 However, Ext Direct might be nice to use if you already are using it a
 lot and have everything set up for it.
 In any case, Ext Direct is fully supported, and since it's also based on
 AJAX, the user experience is pretty much the same.
\end_layout

\begin_layout Standard
You will need to add an extra attribute when setting up Ext Direct, to make
 sure that it supports form submission, and also return the results in the
 appropriate format.
 Here's an example 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

, similar to the one for the RPC Service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var Calc = {
\end_layout

\begin_layout Plain Layout

	multiply: {
\end_layout

\begin_layout Plain Layout

		fn: function(x, y) {
\end_layout

\begin_layout Plain Layout

			return {
\end_layout

\begin_layout Plain Layout

				success: true,
\end_layout

\begin_layout Plain Layout

				msg: '{0} times {1} is {2}'.cast(x, y, x * y)
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		extDirect: {
\end_layout

\begin_layout Plain Layout

			formHandler: true
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	calc: new Diligence.Sencha.DirectResource({name: 'MyApp', namespaces: {Calc:
 Calc}})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, on the client you would create your form 
\emph on
after
\emph default
 initializing Ext Direct like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

function openForm() {
\end_layout

\begin_layout Plain Layout

	Ext.create('Ext.window.Window', {
\end_layout

\begin_layout Plain Layout

		title: 'MyForm',
\end_layout

\begin_layout Plain Layout

		width: 350,
\end_layout

\begin_layout Plain Layout

		items: {
\end_layout

\begin_layout Plain Layout

			xtype: 'form',
\end_layout

\begin_layout Plain Layout

			api: {
\end_layout

\begin_layout Plain Layout

				submit: MyApp.Calc.multiply
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}).show();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Ext.onReady(function() {
\end_layout

\begin_layout Plain Layout

	Ext.Ajax.request({
\end_layout

\begin_layout Plain Layout

		url: '<%= conversation.pathToBase %>/calc/',
\end_layout

\begin_layout Plain Layout

		method: 'GET',
\end_layout

\begin_layout Plain Layout

		disableCaching: false,
\end_layout

\begin_layout Plain Layout

		success: function(response) {
\end_layout

\begin_layout Plain Layout

			var provider = Ext.decode(response.responseText);
\end_layout

\begin_layout Plain Layout

			Ext.Direct.addProvider(provider);
\end_layout

\begin_layout Plain Layout

			openForm();
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that instead of supplying a 
\begin_inset Quotes eld
\end_inset

url
\begin_inset Quotes erd
\end_inset

 key to the form configuration, we use 
\begin_inset Quotes eld
\end_inset

api
\begin_inset Quotes erd
\end_inset

 and hook the 
\begin_inset Quotes eld
\end_inset

submit
\begin_inset Quotes erd
\end_inset

 key to our Ext Direct method.
 Ext JS will take care of the rest.
\end_layout

\begin_layout Section
Sencha Integration: Ext Direct
\end_layout

\begin_layout Standard
Diligence makes it trivial to support 
\begin_inset CommandInset href
LatexCommand href
name "Ext Direct"
target "http://www.sencha.com/products/extjs/extdirect"

\end_inset

, Sencha's straightforward RPC protocol.
 Ext Direct it has excellent support in Ext JS and Sencha Touch: the frameworks
 generate a client-side namespace for you with asynchronous methods equivalent
 to those on the server.
 All you have to do is call them! Operations are batched for maximum efficiency,
 and errors are handled as elegantly as can be.
\end_layout

\begin_layout Standard
Diligence actually takes Ext Direct one step ahead in letting you automatically
 generate the API configuration on the server.
 A 
\begin_inset Quotes eld
\end_inset

GET
\begin_inset Quotes erd
\end_inset

 to the resource will retrieve the JSON needed to configure the client-side
 provider.
 We show this in detail under 
\begin_inset Quotes eld
\end_inset

Usage,
\begin_inset Quotes erd
\end_inset

 below.
\end_layout

\begin_layout Standard
Ext Direct's functionality is practically identical to that 
\begin_inset CommandInset href
LatexCommand href
name "JSON-RPC"
target "http://groups.google.com/group/json-rpc/web/json-rpc-2-0"

\end_inset

, but the protocol is incompatible.
 It may be unfortunate that Sencha decided not to use that better-known
 protocol, but in any case Diligence supports both.
\end_layout

\begin_layout Subsection
Setup
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "server-side API documentation for Savory.Sencha"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Sencha"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "Savory.RPC"
target "http://threecrickets.com/javascript-api/?namespace=Savory.RPC"

\end_inset

, as well as the 
\begin_inset CommandInset href
LatexCommand href
name "client-side API documentation for Ext Direct"
target "http://docs.sencha.com/ext-js/4-1/#!/api/Ext.direct.Manager"

\end_inset

.
\end_layout

\begin_layout Standard
Ext Direct setup is almost identical to RPC Service setup, so make sure
 you read the section there.
\end_layout

\begin_layout Standard
One small difference is in how Ext Direct handles namespaces.
 First of all, you cannot have an empty namespace (the 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 namespace in JSON-RPC).
 And, second, you can optionally set up a client-side namespace, using the
 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 key.
 Here's an example 
\begin_inset Quotes eld
\end_inset

/libraries/resources.js
\begin_inset Quotes erd
\end_inset

, similar to the one for the RPC Service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var Calc = {
\end_layout

\begin_layout Plain Layout

	multiply: function(x, y) {
\end_layout

\begin_layout Plain Layout

		return x * y
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resources = {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	calc: new Diligence.Sencha.DirectResource({name: 'MyApp', namespaces: {Calc:
 Calc}})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is also possible to set Ext Direct method attributes using the long-form
 method definition with the 
\begin_inset Quotes eld
\end_inset

extDirect
\begin_inset Quotes erd
\end_inset

 key.
\end_layout

\begin_layout Subsubsection
Ext JS Forms
\end_layout

\begin_layout Standard
Ext Direct can be used to respond to Ext JS form submissions.
 To do so, we need to set the 
\begin_inset Quotes eld
\end_inset

formHandler
\begin_inset Quotes erd
\end_inset

 attribute and also return an appropriate response:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var Calc = {
\end_layout

\begin_layout Plain Layout

	multiply: {
\end_layout

\begin_layout Plain Layout

		fn: function(x, y) {
\end_layout

\begin_layout Plain Layout

			return {
\end_layout

\begin_layout Plain Layout

				success: true,
\end_layout

\begin_layout Plain Layout

				msg: '{0} times {1} is {2}'.cast(x, y, x * y)
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		},
\end_layout

\begin_layout Plain Layout

		extDirect: {
\end_layout

\begin_layout Plain Layout

			formHandler: true
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See the section on Ext JS Forms for more information on usage.
 Note furthermore that Diligence supports all of Ext JS's form submission
 mechanisms.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
See the Ext JS documentation for full details on the client-side API.
 Otherwise, here's a quick tutorial, which also shows you how to fetch the
 provider configuration from the resource.
\end_layout

\begin_layout Standard
Here's an example of a dynamic web page, say 
\begin_inset Quotes eld
\end_inset

direct.d.html
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

<head>
\end_layout

\begin_layout Plain Layout

<%
\end_layout

\begin_layout Plain Layout

document.executeOnce('/savory/integration/frontend/sencha/')
\end_layout

\begin_layout Plain Layout

Diligence.Sencha.extJsHead(conversation)
\end_layout

\begin_layout Plain Layout

%> 
\end_layout

\begin_layout Plain Layout

</head>
\end_layout

\begin_layout Plain Layout

<body>
\end_layout

\begin_layout Plain Layout

</body>
\end_layout

\begin_layout Plain Layout

<script>
\end_layout

\begin_layout Plain Layout

function init() {
\end_layout

\begin_layout Plain Layout

	MyApp.Calc.multiply(2, 3, function(provider, response) {
\end_layout

\begin_layout Plain Layout

		if (response.type == 'exception') {
\end_layout

\begin_layout Plain Layout

			Ext.Msg.alert('Multiplication', 'Exception: ' + response.message);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else {
\end_layout

\begin_layout Plain Layout

			Ext.Msg.alert('Multiplication', response.result);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	});	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Ext.Ajax.request({
\end_layout

\begin_layout Plain Layout

	url: '<%= conversation.pathToBase %>/calc/',
\end_layout

\begin_layout Plain Layout

	method: 'GET',
\end_layout

\begin_layout Plain Layout

	disableCaching: false,
\end_layout

\begin_layout Plain Layout

	success: function(response) {
\end_layout

\begin_layout Plain Layout

		var provider = Ext.decode(response.responseText);
\end_layout

\begin_layout Plain Layout

		Ext.Direct.addProvider(provider);
\end_layout

\begin_layout Plain Layout

		init();
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	failure: function(response) {
\end_layout

\begin_layout Plain Layout

		console.log(response);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some notes:
\end_layout

\begin_layout Itemize
Make sure you understand the difference between the 
\emph on
server
\emph default
-side JavaScript (between the 
\begin_inset Quotes eld
\end_inset

<%
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

%>
\begin_inset Quotes erd
\end_inset

 delimiters) and the 
\emph on
client
\emph default
-side JavaScript (between the 
\begin_inset Quotes eld
\end_inset

<script>
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

</script>
\begin_inset Quotes erd
\end_inset

 delimiters)!
\end_layout

\begin_layout Itemize
We are using 
\begin_inset Quotes eld
\end_inset

Ext.Ajax.request
\begin_inset Quotes erd
\end_inset

 to do a 
\begin_inset Quotes eld
\end_inset

GET
\begin_inset Quotes erd
\end_inset

 on our resource.
 It will return the JSON needed for the call to 
\begin_inset Quotes eld
\end_inset

Ext.Direct.addProvider
\begin_inset Quotes erd
\end_inset

.
 Here's how it would look in our example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"actions": {
\end_layout

\begin_layout Plain Layout

		"Calc": [{
\end_layout

\begin_layout Plain Layout

			"name": "multiply",
\end_layout

\begin_layout Plain Layout

			"len": 2
\end_layout

\begin_layout Plain Layout

		}]
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"namespace": "MyApp"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

You can avoid that 
\begin_inset Quotes eld
\end_inset

Ext.Ajax.request
\begin_inset Quotes erd
\end_inset

 call by simply copying and pasting that JSON into your client-side source
 code.
 This extra call is simply a convenience allowing you to modify the server-side
 code without worrying about also having to update the client-side code
 accordingly.
 You might prefer to keep this extra call during development, and then freeze
 it for production code.
\end_layout

\begin_layout Itemize
We are disabling the default 
\begin_inset Quotes eld
\end_inset

disableCaching
\begin_inset Quotes erd
\end_inset

 mode in 
\begin_inset Quotes eld
\end_inset

Ext.Ajax.request
\begin_inset Quotes erd
\end_inset

.
 Ext JS disabled caching by default in order to better deal with servers
 that do not handle REST properly.
 Since Prudence does this for us, there's no reason to avoid client-side
 caching if it's possible.
\end_layout

\begin_layout Itemize
The last argument for any Ext Direct method is a callback that is called
 when the server returns a response.
 It's cumbersome, but that's the price you pay for asynchronous remote calls!
 Also note that you want to properly handle server and network failures.
\end_layout

\begin_layout Section
Blog Feature
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Blog"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Blog"

\end_inset

.
\end_layout

\begin_layout Section
Console Feature
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Console"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Console"

\end_inset

.
\end_layout

\begin_layout Section
Contact Us Feature
\end_layout

\begin_layout Standard
This simple feature contains a /web/fragment/ that displays an HTML form
 with a CAPTCHA that allows users to send a message on a specific <a href="../../ser
vice/notification/">notification service</a> channel.
 System administrators or others subscribing to the channel would then receive
 it.
 Straightforward!
\end_layout

\begin_layout Standard
Note that a different form is displayed depending on whether the user is
 logged in.
 Logged-in users will not have to enter their email address or pass the
 CAPTCHA.
 We already know they are legit, by virtue of having logged in!
\end_layout

\begin_layout Standard
The originating IP address is included in the email.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.ContactUs"
target "http://threecrickets.com/javascript-api/?namespace=Savory.ContactUs"

\end_inset

.
\end_layout

\begin_layout Section
Discussion Feature
\end_layout

\begin_layout Standard
This feature lets you attach a 
\begin_inset Quotes eld
\end_inset

forum
\begin_inset Quotes erd
\end_inset

 to any MongoDB document.
 It could be a Page from the Wiki Feature, a blog post, or just anything
 in your application.
 Of course, permissions apply, and you can allow, for example, for registered
 users to post new threads and have 
\begin_inset Quotes eld
\end_inset

visitor
\begin_inset Quotes erd
\end_inset

 users (Facebook, Twitter, etc.) only the right to comment.
 The discussion is threaded, in that comments can have any level of depth.
 It's very easy to drop in, and makes a lot of web application features
 instantly sociable.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Discussion"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Discussion"

\end_inset

.
\end_layout

\begin_layout Subsection
Editable Graph Structures in MongoDB
\end_layout

\begin_layout Standard
If you'll take a look at Diligence's Ext JS tree integration, you'll see
 it's pretty neat.
 It's 
\emph on
literally
\emph default
 neat because the trees for Ext-JS are immutable, and easily stored in a
 MongoDB document, which can hold a structure of arbitrary depth.
 However, if you want your tree to change by multiple users and threads,
 document databases such as MongoDB begin to show some of their limitations.
 (Graph databases, such as neo4j, are of course perfect for this use case.)
\end_layout

\begin_layout Standard
Nevertheless, it's not impossible, and can get excellent all-around performance
 for mutability.
 How is this solved for the Discussion Feature? MongoDB's atomic operations
 do not support such recursion, so we needed a different method.
 You can see ideas on the MongoDB 
\begin_inset CommandInset href
LatexCommand href
name "trees page"
target "http://www.mongodb.org/display/DOCS/Trees+in+MongoDB"

\end_inset

.
\end_layout

\begin_layout Standard
After some consideration, we used a variation of the 
\begin_inset Quotes eld
\end_inset

materialized paths
\begin_inset Quotes erd
\end_inset

 pattern.
 We have the forum posts stored as plain array, with each having a path
 as well as a parent field.
 We parse this document on load, to give it a tree-like structure more amenable
 to work with.
 The flat storage structure, however, allows for easy use of MongoDB's atomic
 update operation.
 For each post, we store a 
\begin_inset Quotes eld
\end_inset

nextResponse
\begin_inset Quotes erd
\end_inset

 running serial.
 We update it atomically with $inc for each new post, to make sure it's
 unique, and append that number to the parent's path to create the new path.
 We then add the new response using MongoDB's $push.
 The result is that any number of users can respond at the same time to
 the same forum, and each response takes only two MongoDB write operations,
 only one of which waits for the response.
 We're guaranteed atomicity and uniqueness of each path ID.
\end_layout

\begin_layout Standard
A graph DB would do this better, but the real comparison would be to a relationa
l database.
 Just two writes, but the whole forum is read with one read.
 We think this counts as a smashing success!
\end_layout

\begin_layout Standard
You'll notice a rule of thumb we've applied here, useful in general when
 working with MongoDB: if in relational database you always want your tables
 to be normalized, in document databases your goal is to use as few documents
 as possible.
 In this case, the entire forum is embedded into one document (together
 with the document's other data, if there is any).
 The document limit in MongoDB is 4MB, easily adequate for such discussions.
 But, what if you want a more open forum, with no limitations on size? Well,
 the Discussion Feature also comes with a forum implementation that stores
 each thread in post in its own document, or even each post in its own document.
 All use the same API.
 Mix and match for the best performance and growth ability suitable for
 your needs.
\end_layout

\begin_layout Section
Registration Feature
\end_layout

\begin_layout Standard
This complement to the <a href="../../service/authentication/">authentication
 service</a> uses a two-step process to allow new users to register to your
 application.
 As is common, it expects users to have a personal email address, which
 will be used to both confirm the identity of the user and to communicate
 with the user when they are not logged in.
\end_layout

\begin_layout Standard
The feature contains a /web/fragment/ HTML form with a CAPTCHA, which collects
 the user's email, username, password and possibly some personal information.
 The form will be valid only of the username is not already in use.
\end_layout

\begin_layout Standard
If the form is valid, the user is created but not yet activated.
 An email is sent to the user with a unique, impossible-to-guess URL, which
 can be used only once.
 If they click on that link, the user is activated.
\end_layout

\begin_layout Standard
The feature allows for not-yet-activated users to be automatically deleted
 after a certain time.
 This would release the username for others to use.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Registration"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Registration"

\end_inset

.
\end_layout

\begin_layout Section
SEO Feature
\end_layout

\begin_layout Standard
This feature helps you comply with a few 
\emph on
de facto
\emph default
 search engine standards to improve your interaction with them, specifically
 robots.txt and sitemap.xml.
\end_layout

\begin_layout Standard
At first glance, there's nothing very sophisticated about these standards,
 and you might be tempted to create the required text files manually and
 then serve them statically.
 However, large applications with many URLs can easily have unwieldy site
 maps.
 This Diligence feature helps you create them and manage them fairly automatical
ly.
 It supports 
\emph on
very, very
\emph default
 large site maps.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.SEO"
target "http://threecrickets.com/javascript-api/?namespace=Savory.SEO"

\end_inset

.
\end_layout

\begin_layout Subsection
The Goods
\end_layout

\begin_layout Subsubsection
robots.txt
\end_layout

\begin_layout Standard
Search engines expect to find this resource right at the root of your domain.
 Its 
\begin_inset CommandInset href
LatexCommand href
name "plain text content"
target "http://www.robotstxt.org/robotstxt.html"

\end_inset

 tells them where to find your sitemap URL, and can also control the crawling
 of your domain.
\end_layout

\begin_layout Standard
Your robots.txt will likely not be very dynamic.
 Because it matches URLs starting with stated URLs, it can easily cover
 large sections of your site, and require infrequent tweaking.
\end_layout

\begin_layout Standard
When would you need a lot of robots.txt tweaking? A common case for large
 sites is that public resources are deprecated or otherwise cancelled.
 In such cases you still want to keep them up for reference, and to allow
 hyperlinks elsewhere on the web to still be able to reach them---there's
 SEO value in that.
 But, you do not want these resources to appear in search engines and confuse
 users (you want them to find the new, better resources).
 A robots.txt exclusion would do the trick.
\end_layout

\begin_layout Subsubsection
sitemap.xml
\end_layout

\begin_layout Standard
If your robots.txt doesn't state otherwise, then this resource will also
 be at the root of your domain.
 Its 
\begin_inset CommandInset href
LatexCommand href
name "XML content"
target "http://sitemaps.org/protocol.php"

\end_inset

 can either list URLs directly, or, more commonly, act as the primary index
 of other XML files called URL sets.
\end_layout

\begin_layout Standard
Search engines do take site maps seriously.
 A carefully maintained site map would help them keep up to date with your
 dynamic site, in turn helping to get human searchers to the page they want
 (or the page you want them to want\SpecialChar \ldots{}
).
 It's likely this would indirectly and directly improve your ranking, too.
\end_layout

\begin_layout Subsection
Dynamic or Static?
\end_layout

\begin_layout Standard
URL sets can grow to be very large (think: Wikipedia), so search engines
 have put limits on file size: 50,000 URLs per file and 10MB, uncompressed.
 That's right, you're allowed to compress your site map files with gzip
 to save bandwidth.
 There doesn't seem to be a limit on the number of files you can serve,
 so potentially your site map can be as big as needed.
\end_layout

\begin_layout Standard
Diligence supports two ways of generating site map resources: dynamic (via
 /web/fragments/) and static (via /web/static/).
 Dynamic is the default, and should be fine for small web sites.
 It generates robots.txt and sitemap.xml on demand, using Prudence's standard
 caching to keep things smooth and fast.
\end_layout

\begin_layout Standard
But, dynamic mode does not support more than 50,000 URLs per URL set.
 What's more, it generates these within the HTTP request thread.
 So, you definitely do not want to use dynamic mode for large sites, or
 sites which are slow to generate the URL sets! If you do, each time you
 get hit by a search engine for the site map (can happen several times a
 day for 
\begin_inset Quotes eld
\end_inset

hot
\begin_inset Quotes erd
\end_inset

 sites!) a web request thread will be tied up for the length of time it
 takes to generate the huge URL set.
 There are two problems for this: first and worst, the search engine may
 penalize you for being so slow, and second, even if you are caching aggressivel
y, it means that you will occasionally have one 
\emph on
very
\emph default
 heavy request, breaking the ironclad rules laid out in Prudence's <a href="http
://threecrickets.com/prudence/scaling/">Scaling Tips</a> article.
\end_layout

\begin_layout Standard
Static mode can support URL sets of any size: it works by generating all
 required files in an asynchronous Prudence task so that they can take as
 much time as necessary, without tying up any user thread.
 You can set the task to run via Prudence's crontab: once a day, twice a
 day, etc.
 The task makes sure to split URL sets into 
\begin_inset Quotes eld
\end_inset

pages
\begin_inset Quotes erd
\end_inset

 of 50,000 URLs max, and to gzip compress them.
 It even makes sure to generate them in a separate spool directory, and
 then swap them all at once, so that search engines hitting your site exactly
 during site map generation don't see a partial, inconsistent picture.
 And it all happens asynchronously, using Diligence tasks, so that multiple
 URL sets can be generated simultaneously.
 And, of course, since they are plain old files, you can also host them
 outside of Prudence.
\end_layout

\begin_layout Standard
Note that robots.txt is always generated dynamically: its size limit is 100KB,
 which should be manageable.
 The implication is that you can't go crazy with very large lists of exclusions/
inclusions.
 If this is an issue, you can use 
\begin_inset CommandInset href
LatexCommand href
name "meta tags"
target "http://www.robotstxt.org/meta.html"

\end_inset

 instead.
\end_layout

\begin_layout Subsection
Instruction Manual
\end_layout

\begin_layout Standard
Every application in your Prudence instance can have its own URL sets, but
 it only makes sense for the root application to have both robots.txt and
 sitemap.xml.
 We'll start our guide with an application that is 
\emph on
not
\emph default
 the at root, because it's simpler.
\end_layout

\begin_layout Standard
From our settings.js:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

predefinedGlobals = Sincerity.Objects.flatten({
\end_layout

\begin_layout Plain Layout

	savory: {
\end_layout

\begin_layout Plain Layout

		feature: {
\end_layout

\begin_layout Plain Layout

			seo: {
\end_layout

\begin_layout Plain Layout

				domains: [{
\end_layout

\begin_layout Plain Layout

					rootUri: 'http://localhost:8080'
\end_layout

\begin_layout Plain Layout

				}, {
\end_layout

\begin_layout Plain Layout

					rootUri: 'http://threecrickets.com'
\end_layout

\begin_layout Plain Layout

				}],
\end_layout

\begin_layout Plain Layout

				locations: [{
\end_layout

\begin_layout Plain Layout

					name: 'the-real-thing',
\end_layout

\begin_layout Plain Layout

					domains: ['http://localhost:8080', 'http://threecrickets.com'],
\end_layout

\begin_layout Plain Layout

					locations: ['/happy/', '/this/', '/is/', '/working/'],
\end_layout

\begin_layout Plain Layout

					exclusions: ['/savory/media/', '/savory/style/', '/savory/script/'],
\end_layout

\begin_layout Plain Layout

					inclusions: ['/savory/media/name/'],
\end_layout

\begin_layout Plain Layout

					factory: 'Explicit'
\end_layout

\begin_layout Plain Layout

				}, {
\end_layout

\begin_layout Plain Layout

					name: 'test',
\end_layout

\begin_layout Plain Layout

					domains: ['http://localhost:8080'],
\end_layout

\begin_layout Plain Layout

					factory: 'Fake',
\end_layout

\begin_layout Plain Layout

					dependency: '/about/feature/seo/fake-locations/'
\end_layout

\begin_layout Plain Layout

				}]
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the two arrays: domains and locations.
 There is a many-to-many connection between them, such your application
 can support many domains, many location groups, and apply different locations
 groups to different domains.
 This is because Prudence allows for multiple virtual hosting, so that each
 application may very well be running on different domains at the same time,
 and may want to present itself differently to search engines on each domain.
\end_layout

\begin_layout Standard
If you don't need to support virtual hosting, ignore the domains array and
 domains parameters: it will be assumed that your locations are to be applied
 to all domains.
 </p> <p> You then route the SEO resources for the application in its routing.js:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/feature/seo/')
\end_layout

\begin_layout Plain Layout

Diligence.SEO.routing()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Locations
\end_layout

\begin_layout Standard
Locations are configured using Diligence's plug-in library, which uses the
 factory pattern to generate plug-ins.
 In our first locations config, we used the 
\begin_inset Quotes eld
\end_inset

Explicit
\begin_inset Quotes erd
\end_inset

 factory, which is built-in to the SEO feature.
 This lets use explicitly list our locations as arrays within the config.
 Obviously, this is useful only for very small sites with a known list of
 URLs.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 field is important: this becomes exactly the name of the URL set as it
 appears in the site map.
 As for exclusions and inclusions: they are lumped into robots.txt.
\end_layout

\begin_layout Standard
More interesting is our second locations config: it uses our own factory,
 which we called 
\begin_inset Quotes eld
\end_inset

Fake
\begin_inset Quotes erd
\end_inset

.
 This factory generates lots and lots (300,000) fake locations, and is useful
 for testing out very large site maps.
 (Bottom line: it takes about 7 seconds to generate the complete, gzip-compresse
d 7-page site map for that many URLs.) It's also a good example for you to
 use to create your own location factories.
\end_layout

\begin_layout Standard
The key to factory success is understanding the <a href="../../foundation/iterators/
">Diligence iterators library</a>: as long as you keep your iterator properly
 fed, you should be able to scale to site maps of scary sizes.
\end_layout

\begin_layout Standard
One more thing to note is that each locations config will be executed simultaneo
usly on its own tasks thread, and this is true for all locations configs
 on all applications which you include in your root application, as detailed
 below.
\end_layout

\begin_layout Subsubsection
The Root Application
\end_layout

\begin_layout Standard
At minimum, the settings.js of the root application should look something
 like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

predefinedGlobals = Sincerity.Objects.flatten({
\end_layout

\begin_layout Plain Layout

	savory: {
\end_layout

\begin_layout Plain Layout

		feature: {
\end_layout

\begin_layout Plain Layout

			seo: {
\end_layout

\begin_layout Plain Layout

				domains: [{
\end_layout

\begin_layout Plain Layout

					rootUri: 'http://localhost:8080',
\end_layout

\begin_layout Plain Layout

					applications: [{
\end_layout

\begin_layout Plain Layout

						name: 'My Application',
\end_layout

\begin_layout Plain Layout

						internalName: 'myapp'
\end_layout

\begin_layout Plain Layout

					}],
\end_layout

\begin_layout Plain Layout

					delaySeconds: 100,
\end_layout

\begin_layout Plain Layout

					dynamic: false,
\end_layout

\begin_layout Plain Layout

					staticRelativePath: 'sitemap-local',
\end_layout

\begin_layout Plain Layout

					workRelativePath: 'sitemap-local'
\end_layout

\begin_layout Plain Layout

				}]
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll see that we added a few more fields to our domain config: beyond
 the root URI, we are also configuring our robots.txt here, which we will
 be hosting, and configuring the paths to use for static generation.
 The static path is relative to the application's /web/static/ directory,
 while the work path will be under your application's root directory's 
\begin_inset Quotes eld
\end_inset

work
\begin_inset Quotes erd
\end_inset

 subdirectory.
 Alternatively, you can use 
\begin_inset Quotes eld
\end_inset

staticPath
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

workPath
\begin_inset Quotes erd
\end_inset

 to provide absolute paths.
 For example, you might prefer to use 
\begin_inset Quotes eld
\end_inset

workPath: '/tmp/sitemap'
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Note that these paths are per domain: if you hosting multiple domains via
 virtual hosting, each site map should go to a different path.
 Via a simple <a href="http://threecrickets.com/prudence/manual/handlers/#filters
">capturing filter</a> we make sure that each domain gets it correct site
 map.
 Thus, the outside world doesn't actually see these static subdirectories:
 the URI space for the site map all appears, publicly, at the root.
\end_layout

\begin_layout Standard
The truly magical field is 
\begin_inset Quotes eld
\end_inset

applications
\begin_inset Quotes erd
\end_inset

: this is an array of application names for which locations will be added
 to this domain.
 The URL sets for each application for this will be merged into the main
 site map, and its exclusions/inclusions will be merged into robots.txt.
 It's up to you to make sure that URL set names from all applications don't
 overlap, since their files are all moved into the same static directory.
\end_layout

\begin_layout Standard
The root application can also have its own 
\begin_inset Quotes eld
\end_inset

locations
\begin_inset Quotes erd
\end_inset

 field, which will also be merged in.
 We omitted it in this example for simplicity.
\end_layout

\begin_layout Standard
To have your site map generated regularly, put something like the following
 in your <a href="http://threecrickets.com/prudence/manual/tasks/#toc-Subsection-
54">application's crontab</a> (as a single line).
 In this example, we're having our site map generator run every day at 4:00AM:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

0 4 * * * /savory/eval/ document.executeOnce('/savory/feature/seo/'); SEO.getDomai
n('http://localhost:8080').generateStatic();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You then route the SEO resources for the root application in its routing.js:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/feature/seo/')
\end_layout

\begin_layout Plain Layout

Diligence.SEO.routing(true)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Well, one tiny little convenience here: though you do need to install the
 routes in your root application, you are free to host the SEO resources
 on another app (works via the magic of Prudence's <a href="http://threecrickets.
com/prudence/manual/routing/#toc-Subsubsection-100">router.captureOther</a>).
 So, we can call SEO.install(true, 'myapp').
\end_layout

\begin_layout Standard
\SpecialChar \ldots{}
And do all of the SEO stuff on myapp, even though it's not at root.
 The root application really doesn't have to do anything else.
\end_layout

\begin_layout Standard
Optionally, you can also <a href="http://threecrickets.com/prudence/manual/static
-web/#toc-Subsection-55">register the 
\begin_inset Quotes eld
\end_inset

.gz
\begin_inset Quotes erd
\end_inset

 extension</a> to serve the gzip MIME type.
 Search engines would not really care, but it makes your URI-space more
 correct and debuggable.
 Do this in the application's default.js:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

document.executeOnce('/savory/feature/seo/')
\end_layout

\begin_layout Plain Layout

Diligence.SEO.registerExtensions()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that's pretty much it!
\end_layout

\begin_layout Section
Shopping Cart Feature
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.ShoppingCart"
target "http://threecrickets.com/javascript-api/?namespace=Savory.ShoppingCart"

\end_inset

.
\end_layout

\begin_layout Section
Wiki Feature
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Make sure to check out the 
\begin_inset CommandInset href
LatexCommand href
name "API documentation for Savory.Wiki"
target "http://threecrickets.com/javascript-api/?namespace=Savory.Wiki"

\end_inset

.
\end_layout

\end_body
\end_document
